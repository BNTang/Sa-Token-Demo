# 并发 (Concurrency)

> 基于《Clean Code》第13章 - Robert C. Martin (by Brett L. Schuchert)

## 核心思想

> "对象是处理的抽象。线程是调度的抽象。"
> — James O. Coplien

编写整洁的并发程序很难——非常难。编写在单线程中执行的代码容易得多。编写表面上看起来没问题、但在更深层次上是错误的多线程代码也很容易。这样的代码在系统承受压力之前运行良好。

---

## 为什么需要并发？

### 并发是一种解耦策略

```
┌─────────────────────────────────────────────────────────────┐
│  并发帮助我们将"做什么"与"何时做"解耦                         │
│                                                             │
│  单线程应用：什么和何时强耦合                                 │
│  并发应用：系统看起来像许多小型协作计算机                     │
└─────────────────────────────────────────────────────────────┘
```

### 并发的动机

| 场景 | 问题 | 并发解决方案 |
|------|------|-------------|
| 信息聚合器 | 顺序访问多个网站，24小时内无法完成 | 多线程同时访问多个网站 |
| 用户请求处理 | 每用户1秒，150个用户排队等待太久 | 并发处理多个用户 |
| 大数据集处理 | 单机处理时间过长 | 多机并行处理 |

---

## 神话与误解

### ❌ 常见误解

| 误解 | 现实 |
|-----|------|
| 并发总是能提高性能 | 只在有大量等待时间可以被多线程共享时才能提高性能 |
| 编写并发程序时设计不需要改变 | 并发算法的设计可能与单线程系统的设计**截然不同** |
| 使用 Web/EJB 容器时不需要理解并发问题 | 你最好知道容器在做什么，以及如何防范并发更新和死锁 |

### ✅ 更平衡的认知

- 并发会产生开销——性能和额外代码
- 即使对于简单问题，正确的并发也很复杂
- 并发 bug 通常不可重现，常被当作"偶发"忽略
- 并发通常需要设计策略的根本改变

---

## 并发的挑战

### 经典示例

```java
public class X {
    private int lastIdUsed;
    
    public int getNextId() {
        return ++lastIdUsed;
    }
}
```

假设 `lastIdUsed = 42`，两个线程同时调用 `getNextId()`：

| 可能结果 | 说明 |
|---------|------|
| 线程1得到43，线程2得到44 ✅ | 正确 |
| 线程1得到44，线程2得到43 ✅ | 正确 |
| 线程1得到43，线程2得到43 ❌ | **两个线程踩到对方** |

**惊人的数据**：仅这一行 Java 代码，两个线程有 **12,870** 种可能的执行路径！如果 `lastIdUsed` 改为 `long`，可能路径增加到 **2,704,156** 种。

---

## 并发防御原则

### 原则 1：单一职责原则 (SRP)

```
┌─────────────────────────────────────────────────────────────┐
│  并发相关代码有其自己的开发、变更和调优生命周期               │
│  并发相关代码有其自己的挑战，不同于且通常比非并发代码更难     │
│                                                             │
│  ▶ 将并发相关代码与其他代码分离                             │
└─────────────────────────────────────────────────────────────┘
```

### 原则 2：限制数据作用域

```java
// 两个线程修改共享对象的同一字段会相互干扰

// 问题：共享数据更新的地方越多
// • 越容易忘记保护其中某一处
// • 需要更多重复努力确保所有地方都被保护（违反 DRY）
// • 更难确定失败来源
```

**建议**：认真对待数据封装；严格限制任何可能被共享的数据的访问。

### 原则 3：使用数据副本

```java
// 避免共享数据的好方法：一开始就不共享

// 选项 1：复制对象并将其视为只读
// 选项 2：复制对象，在多个线程中收集结果，然后在单个线程中合并

// 如果使用副本可以避免同步，节省的内在锁开销
// 可能抵消额外的创建和垃圾回收开销
```

### 原则 4：线程应尽可能独立

```java
// 理想情况：每个线程存在于自己的世界，不与其他线程共享数据

// HttpServlet 示例
public class MyServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
        // 所有信息作为参数传入
        // 只要代码只使用局部变量，就不会引起同步问题
        String param = req.getParameter("key");  // 来自请求
        // 处理...
    }
}
```

**建议**：尝试将数据分区成可以由独立线程操作的独立子集，可能在不同处理器上。

---

## 了解你的库

### Java 5+ 并发工具

| 类别 | 推荐 |
|-----|------|
| **线程安全集合** | `ConcurrentHashMap`（几乎所有情况下比 `HashMap` 性能更好） |
| **执行器框架** | 用于执行不相关的任务 |
| **非阻塞方案** | 尽可能使用 |
| **原子类** | `java.util.concurrent.atomic` |
| **锁** | `java.util.concurrent.locks` |

```java
// ConcurrentHashMap 优势
// • 允许同时并发读写
// • 支持通常不是线程安全的复合操作
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
map.putIfAbsent("key", 1);  // 原子操作
map.computeIfAbsent("key", k -> expensiveComputation(k));
```

---

## 了解你的执行模型

### 基本定义

| 术语 | 定义 |
|-----|------|
| **绑定资源** | 固定大小的资源（数据库连接、固定大小读写缓冲区） |
| **互斥** | 同一时间只有一个线程可以访问共享数据或资源 |
| **饥饿** | 一个或一组线程被禁止过长时间或永久继续 |
| **死锁** | 两个或多个线程互相等待对方完成 |
| **活锁** | 线程在响应其他线程的动作时无法取得进展 |

### 执行模型 1：生产者-消费者

```
┌──────────────┐         ┌──────────────┐         ┌──────────────┐
│   生产者      │ ──────→ │    队列      │ ──────→ │   消费者      │
│  创建工作     │         │  （绑定资源）  │         │  完成工作     │
└──────────────┘         └──────────────┘         └──────────────┘
         │                      │                        │
         └──── 等待空间 ────────┴──── 等待内容 ───────────┘
```

- 生产者等待队列有空间才写入
- 消费者等待队列有内容才消费
- 双方通过队列相互发信号

### 执行模型 2：读者-写者

```
┌─────────────────────────────────────────────────────────────┐
│  共享资源主要作为读者的信息源，偶尔由写者更新                  │
│                                                             │
│  挑战：                                                     │
│  • 强调吞吐量可能导致饥饿和陈旧信息累积                       │
│  • 允许更新会影响吞吐量                                      │
│  • 写者倾向于长时间阻塞多个读者                              │
│                                                             │
│  需要平衡读者和写者的需求，满足正确操作、                      │
│  提供合理吞吐量并避免饥饿                                    │
└─────────────────────────────────────────────────────────────┘
```

### 执行模型 3：哲学家就餐

```
      🍴 哲学家1 🍴
    /              \
  🍴                🍴
哲学家5    🍝      哲学家2
  🍴                🍴
    \              /
      🍴 哲学家3 🍴
         🍴
       哲学家4

每个哲学家需要两把叉子才能吃饭
将哲学家替换为线程，叉子替换为资源
= 进程竞争资源的企业应用
```

可能问题：死锁、活锁、吞吐量和效率下降

**建议**：学习这些基本算法并理解它们的解决方案。

---

## 同步方法间的依赖

### 问题

```java
// ❌ 同一共享类上有多个同步方法
public class SharedClass {
    public synchronized void method1() { ... }
    public synchronized void method2() { ... }
    public synchronized void method3() { ... }
}

// 问题：同步方法之间的依赖会导致并发代码中的微妙 bug
```

**建议**：避免在共享对象上使用多个方法。

### 解决方案

| 方案 | 描述 |
|-----|------|
| **客户端锁定** | 让客户端在调用第一个方法之前锁定服务器 |
| **服务端锁定** | 在服务器内创建一个锁定服务器、调用所有方法然后解锁的方法 |
| **适配服务器** | 创建执行锁定的中介（原始服务器无法修改时） |

---

## 保持同步区域小

```java
// synchronized 关键字引入锁
// 锁是昂贵的：创建延迟和开销

// ❌ 天真的做法：使临界区非常大
public synchronized void processAll() {
    // 很多代码...
}

// ✅ 正确的做法：最小化临界区
public void processAll() {
    // 非同步代码...
    synchronized(lock) {
        // 只有必须保护的代码
    }
    // 更多非同步代码...
}
```

**建议**：保持同步区域尽可能小。

---

## 正确编写关闭代码很难

### 常见问题

```
┌─────────────────────────────────────────────────────────────┐
│  父线程生成多个子线程，等待它们全部完成后再释放资源           │
│                                                             │
│  问题 1：如果一个子线程死锁？父线程永远等待                   │
│                                                             │
│  问题 2：生产者/消费者对                                     │
│  • 父线程指示关闭                                           │
│  • 生产者快速关闭                                           │
│  • 消费者等待生产者的消息，阻塞在无法接收关闭信号的状态       │
│  • 消费者永远不完成，父线程也无法完成                        │
└─────────────────────────────────────────────────────────────┘
```

**建议**：尽早考虑关闭并尽早让它工作。这会比你预期的花更长时间。

---

## 测试线程代码

### 核心建议

```
┌─────────────────────────────────────────────────────────────┐
│  编写有可能暴露问题的测试                                     │
│  用不同的程序配置、系统配置和负载频繁运行它们                  │
│                                                             │
│  如果测试曾经失败，追踪失败原因                               │
│  不要因为后续运行测试通过就忽略失败                           │
└─────────────────────────────────────────────────────────────┘
```

### 测试策略

| 策略 | 说明 |
|-----|------|
| **将偶发失败视为线程问题候选** | 不要将系统失败当作"偶发"忽略 |
| **先让非线程代码工作** | 不要同时追查非线程 bug 和线程 bug |
| **使线程代码可插拔** | 可在多种配置下运行 |
| **使线程代码可调节** | 允许线程数量易于调整 |
| **用比处理器更多的线程运行** | 鼓励任务交换，更可能发现问题 |
| **在不同平台运行** | 不同操作系统有不同的线程策略 |
| **插桩代码以尝试强制失败** | 增加捕获罕见情况的机会 |

### 手动插桩

```java
public synchronized String nextUrlOrNull() {
    if(hasNext()) {
        String url = urlGenerator.next();
        Thread.yield();  // 为测试插入
        updateHasNext();
        return url;
    }
    return null;
}
```

**问题**：
- 必须手动找到合适的地方
- 不知道在哪里放置调用以及使用哪种调用
- 在生产环境中留下这样的代码会不必要地减慢代码

### 自动化插桩

```java
// 创建一个抖动点类
public class ThreadJigglePoint {
    public static void jiggle() {
        // 生产环境：什么都不做
        // 测试环境：随机选择 sleep、yield 或直接通过
    }
}

// 在代码中添加抖动点
public synchronized String nextUrlOrNull() {
    if(hasNext()) {
        ThreadJigglePoint.jiggle();
        String url = urlGenerator.next();
        ThreadJigglePoint.jiggle();
        updateHasNext();
        ThreadJigglePoint.jiggle();
        return url;
    }
    return null;
}
```

**工具推荐**：IBM ConTest

**建议**：使用抖动策略来发现错误。

---

## 代码审查清单

### 设计原则
- [ ] 并发代码是否与其他代码分离？（SRP）
- [ ] 共享数据的访问是否被严格限制？
- [ ] 是否尽可能使用数据副本而非共享？
- [ ] 线程是否尽可能独立？

### 同步
- [ ] 同步区域是否尽可能小？
- [ ] 是否避免在共享对象上使用多个同步方法？
- [ ] 是否正确处理同步方法间的依赖？

### 库使用
- [ ] 是否使用线程安全集合（如 `ConcurrentHashMap`）？
- [ ] 是否熟悉 `java.util.concurrent` 包？
- [ ] 是否使用执行器框架执行任务？

### 执行模型
- [ ] 是否理解生产者-消费者模式？
- [ ] 是否理解读者-写者问题？
- [ ] 是否理解哲学家就餐问题？

### 关闭
- [ ] 是否尽早考虑关闭逻辑？
- [ ] 是否处理了可能的死锁场景？

### 测试
- [ ] 是否将偶发失败视为真正的缺陷？
- [ ] 非线程代码是否先单独测试？
- [ ] 是否在多种配置下运行测试？
- [ ] 是否在不同平台上测试？
- [ ] 是否使用插桩/抖动策略？

---

## 核心箴言

> **并发代码很难做对。简单易懂的代码在多线程和共享数据混入后可能变成噩梦。**

> **首先遵循单一职责原则。将系统分解成 POJO，将线程感知代码与线程无关代码分开。**

> **学会找到必须锁定的代码区域并锁定它们。不要锁定不需要锁定的代码区域。**

> **不要将系统失败当作"偶发"忽略。线程 bug 可能每千次或百万次执行才出现一次。**

> **如果采用整洁的方法，正确的机会会大大增加。**
