# 消息队列如何处理消息堆积

> 分类: 消息队列 | 难度: ⭐⭐⭐⭐ | 频率: 高频

---

## 一、消息堆积的原因

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          消息堆积的原因                                           │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  生产速度 > 消费速度                                                             │
│                                                                                  │
│  1. 生产端                                                                       │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │  • 突发流量: 秒杀、促销活动                                                 │ │
│  │  • 批量发送: 定时任务批量推送                                               │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
│  2. 消费端                                                                       │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │  • 消费者少: 消费者数量不足                                                 │ │
│  │  • 消费慢: 单条消息处理耗时长 (调用第三方接口、复杂计算)                    │ │
│  │  • 消费异常: 消费失败反复重试                                               │ │
│  │  • 消费者宕机: 服务不可用                                                   │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
│  3. MQ 自身                                                                      │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │  • 分区数不足: 限制了消费者并发                                             │ │
│  │  • Broker 性能瓶颈: 磁盘 IO、网络带宽                                       │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 二、解决方案

### 2.1 紧急处理 (临时扩容)

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          紧急扩容方案                                             │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  方案1: 增加消费者实例                                                           │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │  原来: 1个Topic, 3个分区, 3个消费者                                         │ │
│  │  扩容: 启动更多消费者实例 (但不能超过分区数)                                │ │
│  │                                                                             │ │
│  │  Kafka: 消费者数 <= 分区数                                                  │ │
│  │  RocketMQ: 消费者数可以 > 队列数                                            │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
│  方案2: 增加分区/队列数                                                          │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │  # Kafka 增加分区                                                           │ │
│  │  kafka-topics.sh --alter --topic my-topic --partitions 10                  │ │
│  │                                                                             │ │
│  │  注意: 增加分区后再增加消费者                                               │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
│  方案3: 临时转发到新 Topic                                                       │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │  堆积Topic ──→ 临时消费者 ──→ 新Topic (更多分区) ──→ 更多消费者            │ │
│  │                                                                             │ │
│  │  快速消费堆积消息，不做业务处理，只做转发                                   │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 提升消费能力

```java
/**
 * 方案1: 批量消费
 */
@KafkaListener(topics = "order-topic", groupId = "order-group")
public void consume(List<ConsumerRecord<String, String>> records) {
    // 批量处理，减少网络开销
    List<Order> orders = records.stream()
        .map(r -> JSON.parseObject(r.value(), Order.class))
        .collect(Collectors.toList());
    
    // 批量入库
    orderMapper.batchInsert(orders);
}

/**
 * 方案2: 多线程消费
 */
@KafkaListener(topics = "order-topic", groupId = "order-group")
public void consume(ConsumerRecord<String, String> record) {
    // 提交到线程池处理
    executorService.submit(() -> {
        processOrder(record.value());
    });
}

/**
 * 方案3: 异步处理 (先入库，后处理)
 */
@KafkaListener(topics = "order-topic", groupId = "order-group")
public void consume(ConsumerRecord<String, String> record) {
    // 1. 快速入库
    messageLogMapper.insert(record.value());
    
    // 2. 另一个服务异步处理
    // 定时任务扫描 message_log 表处理
}
```

### 2.3 优化消费逻辑

```java
/**
 * 优化消费耗时
 */
public class OptimizedConsumer {
    
    // 优化1: 减少远程调用
    // 批量查询代替逐条查询
    public void process(List<Order> orders) {
        List<Long> userIds = orders.stream()
            .map(Order::getUserId)
            .collect(Collectors.toList());
        
        // 批量查询用户信息
        Map<Long, User> userMap = userService.batchGetUsers(userIds);
    }
    
    // 优化2: 使用缓存
    @Cacheable(value = "user", key = "#userId")
    public User getUser(Long userId) {
        return userMapper.selectById(userId);
    }
    
    // 优化3: 异步调用
    public void process(Order order) {
        // 主流程
        orderService.save(order);
        
        // 异步发送通知
        CompletableFuture.runAsync(() -> {
            notifyService.sendNotification(order);
        });
    }
}
```

### 2.4 RocketMQ 消费者配置

```java
/**
 * RocketMQ 消费者优化配置
 */
@Configuration
public class RocketMQConfig {
    
    @Bean
    public DefaultMQPushConsumer consumer() throws Exception {
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("my-group");
        
        // 设置消费线程数
        consumer.setConsumeThreadMin(20);
        consumer.setConsumeThreadMax(64);
        
        // 每次拉取消息数量
        consumer.setPullBatchSize(32);
        
        // 每次消费消息数量
        consumer.setConsumeMessageBatchMaxSize(10);
        
        // 流控阈值 (本地缓存消息数)
        consumer.setPullThresholdForQueue(1000);
        
        return consumer;
    }
}
```

---

## 三、预防措施

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          预防消息堆积                                             │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  1. 合理设置分区数                                                               │
│     分区数 >= 预期最大消费者数                                                   │
│                                                                                  │
│  2. 消费者监控告警                                                               │
│     监控 Consumer Lag，堆积超阈值告警                                            │
│                                                                                  │
│  3. 消费能力评估                                                                 │
│     预估峰值流量，确保消费能力足够                                               │
│                                                                                  │
│  4. 降级方案                                                                     │
│     堆积时跳过非核心消息，优先处理核心业务                                       │
│                                                                                  │
│  5. 死信队列                                                                     │
│     消费失败的消息进入死信队列，不影响正常消费                                   │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 四、面试回答

### 30秒版本

> **堆积原因**：生产速度 > 消费速度（消费者少、消费慢、分区不足）。
>
> **紧急处理**：
> 1. 增加消费者实例
> 2. 增加分区数
> 3. 临时转发到新 Topic
>
> **提升消费能力**：批量消费、多线程处理、异步处理、优化消费逻辑。
>
> **预防**：合理分区数、消费监控告警、死信队列。

### 1分钟版本

> **消息堆积原因**：
> - 生产端：突发流量、批量发送
> - 消费端：消费者少、处理慢、异常重试、宕机
> - MQ：分区数不足
>
> **紧急处理方案**：
> 1. **增加消费者**：快速扩容消费实例（Kafka 不能超过分区数）
> 2. **增加分区**：先增加分区，再增加消费者
> 3. **临时转发**：快速消费只做转发，发到新 Topic 处理
>
> **提升消费能力**：
> - 批量消费：减少网络开销
> - 多线程消费：提交到线程池并行处理
> - 异步处理：先入库再异步处理
> - 优化逻辑：批量查询、缓存、异步调用
>
> **预防措施**：
> - 分区数 >= 最大消费者数
> - 监控 Consumer Lag，超阈值告警
> - 消费失败进死信队列，不阻塞正常消费
> - 有降级方案，堆积时跳过非核心消息
