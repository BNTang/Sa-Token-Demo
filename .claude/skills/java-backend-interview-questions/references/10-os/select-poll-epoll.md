# Select、Poll、Epoll 区别

> 分类: I/O多路复用 | 难度: ⭐⭐⭐⭐ | 频率: 高频

---

## 一、概述

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                    I/O 多路复用机制                                               │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  定义: 使用单个线程同时监听多个文件描述符(socket)，当某个fd就绪时再进行处理        │
│                                                                                  │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │                           演进历史                                          │ │
│  │                                                                             │ │
│  │  select (1983)  →  poll (1997)  →  epoll (Linux 2.6, 2002)                 │ │
│  │    ↑                   ↑                  ↑                                 │ │
│  │  最早的多路复用    改进fd数量限制      彻底解决性能问题                      │ │
│  │                                                                             │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 二、Select

### 2.1 工作原理

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          Select 工作原理                                          │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   用户空间                                                                       │
│   ┌────────────────────────────────────────────────────────────────────────────┐│
│   │  fd_set (位图结构，每个bit代表一个fd)                                       ││
│   │  ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬─────────┐                       ││
│   │  │ 0 │ 1 │ 1 │ 0 │ 1 │ 0 │ 0 │ 1 │...│...│  最大1024 │                      ││
│   │  └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴─────────┘                       ││
│   │   fd0 fd1 fd2 fd3 fd4                                                       ││
│   │   监控 fd1, fd2, fd4, fd7                                                   ││
│   └──────────────────────────────────────────────────────────────────────────────┘│
│                              │                                                   │
│                              │ 1. 拷贝 fd_set 到内核                             │
│                              ↓                                                   │
│   内核空间                                                                       │
│   ┌────────────────────────────────────────────────────────────────────────────┐│
│   │  2. 遍历所有fd，检查是否就绪                                                ││
│   │  3. 将就绪的fd标记在fd_set中                                                ││
│   │  4. 返回就绪fd的数量                                                        ││
│   └────────────────────────────────────────────────────────────────────────────┘│
│                              │                                                   │
│                              ↓ 5. 拷贝 fd_set 到用户空间                         │
│   用户空间                                                                       │
│   ┌────────────────────────────────────────────────────────────────────────────┐│
│   │  6. 用户遍历 fd_set，找出就绪的 fd                                          ││
│   └────────────────────────────────────────────────────────────────────────────┘│
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 Select 代码示例

```c
// C语言 select 示例
fd_set readfds;
FD_ZERO(&readfds);
FD_SET(socket_fd, &readfds);

struct timeval timeout;
timeout.tv_sec = 5;
timeout.tv_usec = 0;

int ret = select(max_fd + 1, &readfds, NULL, NULL, &timeout);
if (ret > 0) {
    for (int i = 0; i <= max_fd; i++) {
        if (FD_ISSET(i, &readfds)) {
            // fd i 可读
            handle_read(i);
        }
    }
}
```

### 2.3 Select 缺点

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          Select 缺点                                              │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  1. fd 数量限制: 最大 1024 (FD_SETSIZE)                                          │
│                                                                                  │
│  2. 每次调用都需要:                                                              │
│     • 将 fd_set 从用户空间拷贝到内核空间                                         │
│     • 内核遍历所有 fd 检查就绪状态                                               │
│     • 将 fd_set 拷贝回用户空间                                                   │
│     O(n) 复杂度                                                                  │
│                                                                                  │
│  3. 返回后用户还需要遍历整个 fd_set 找出就绪的 fd                                │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 三、Poll

### 3.1 工作原理

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          Poll 工作原理                                            │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   使用 pollfd 数组代替 fd_set 位图:                                               │
│                                                                                  │
│   struct pollfd {                                                                │
│       int   fd;        // 文件描述符                                              │
│       short events;    // 关注的事件 (POLLIN, POLLOUT等)                          │
│       short revents;   // 实际发生的事件 (由内核填充)                              │
│   };                                                                              │
│                                                                                  │
│   ┌─────────────────────────────────────────────────────────────────────────┐   │
│   │  pollfd 数组                                                             │   │
│   │  ┌────────────────────┬────────────────────┬────────────────────┬────┐  │   │
│   │  │ fd=5, events=POLLIN│ fd=8, events=POLLIN│ fd=12,events=POLLIN│... │  │   │
│   │  └────────────────────┴────────────────────┴────────────────────┴────┘  │   │
│   └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                  │
│   与 select 的主要区别:                                                          │
│   • 没有 fd 数量限制 (数组大小由用户决定)                                        │
│   • 使用数组结构，更清晰                                                         │
│   • 事件和返回事件分开，不需要每次重新设置                                        │
│                                                                                  │
│   仍然存在的问题:                                                                │
│   • 每次调用需要拷贝整个数组到内核                                               │
│   • 内核仍需遍历所有 fd                                                          │
│   • 返回后用户仍需遍历数组                                                       │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Poll 代码示例

```c
// C语言 poll 示例
struct pollfd fds[MAX_FDS];
fds[0].fd = socket_fd;
fds[0].events = POLLIN;

int ret = poll(fds, nfds, 5000);  // 5秒超时
if (ret > 0) {
    for (int i = 0; i < nfds; i++) {
        if (fds[i].revents & POLLIN) {
            handle_read(fds[i].fd);
        }
    }
}
```

---

## 四、Epoll

### 4.1 工作原理

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          Epoll 工作原理                                           │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   1. 事件驱动，不是轮询                                                          │
│   2. 在内核维护一个 fd 集合 (红黑树)                                             │
│   3. 只返回就绪的 fd，不需要遍历所有                                             │
│                                                                                  │
│   ┌─────────────────────────────────────────────────────────────────────────┐   │
│   │                          内核空间                                        │   │
│   │                                                                          │   │
│   │   ┌─────────────────┐         ┌─────────────────┐                       │   │
│   │   │   红黑树         │         │   就绪链表       │                       │   │
│   │   │  (存储所有fd)    │         │  (存储就绪fd)    │                       │   │
│   │   │                 │         │                 │                       │   │
│   │   │      fd5        │    ──→  │  fd5 ─→ fd8    │                       │   │
│   │   │     /   \       │  事件就绪│                 │                       │   │
│   │   │   fd3   fd8     │    ──→  │                 │                       │   │
│   │   │   / \     \     │         │                 │                       │   │
│   │   │ fd1 fd4   fd12  │         │                 │                       │   │
│   │   └─────────────────┘         └─────────────────┘                       │   │
│   │                                       ↓                                  │   │
│   └───────────────────────────────────────┼─────────────────────────────────┘   │
│                                           │ 只返回就绪fd                         │
│                                           ↓                                      │
│   ┌─────────────────────────────────────────────────────────────────────────┐   │
│   │                          用户空间                                        │   │
│   │   epoll_event events[MAX_EVENTS];                                        │   │
│   │   只需处理返回的就绪 fd，无需遍历                                        │   │
│   └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 Epoll API

```c
// 1. 创建 epoll 实例
int epfd = epoll_create(1024);  // 参数现在被忽略

// 2. 添加/修改/删除 fd
struct epoll_event ev;
ev.events = EPOLLIN;
ev.data.fd = socket_fd;
epoll_ctl(epfd, EPOLL_CTL_ADD, socket_fd, &ev);

// 3. 等待事件
struct epoll_event events[MAX_EVENTS];
int nfds = epoll_wait(epfd, events, MAX_EVENTS, timeout);

// 4. 处理就绪的 fd (只遍历就绪的，不是全部)
for (int i = 0; i < nfds; i++) {
    if (events[i].events & EPOLLIN) {
        handle_read(events[i].data.fd);
    }
}
```

### 4.3 LT 和 ET 模式

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                    LT (水平触发) vs ET (边缘触发)                                 │
├─────────────────┬────────────────────────────┬───────────────────────────────────┤
│                 │         LT (默认)          │           ET                      │
├─────────────────┼────────────────────────────┼───────────────────────────────────┤
│   触发时机      │  只要缓冲区有数据就触发    │  只在状态变化时触发一次           │
│   数据读取      │  可以只读部分，下次还触发  │  必须一次读完，否则不再通知       │
│   编程难度      │  简单                      │  复杂，需配合非阻塞IO             │
│   效率          │  可能重复触发              │  触发次数少，效率高               │
│   select/poll   │  仅支持 LT                 │  -                                │
└─────────────────┴────────────────────────────┴───────────────────────────────────┘

ET 模式使用示例:
while (true) {
    int n = read(fd, buf, sizeof(buf));
    if (n == -1) {
        if (errno == EAGAIN) break;  // 读完了
        // 处理错误
    }
    if (n == 0) break;  // 连接关闭
    // 处理数据
}
```

---

## 五、三者对比

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                    Select vs Poll vs Epoll                                        │
├─────────────────┬────────────────┬────────────────┬──────────────────────────────┤
│                 │    Select      │     Poll       │        Epoll                 │
├─────────────────┼────────────────┼────────────────┼──────────────────────────────┤
│  fd数量限制     │  1024 (位图)   │  无限制        │  无限制                      │
│  数据结构       │  fd_set 位图   │  pollfd 数组   │  红黑树 + 就绪链表           │
│  fd拷贝         │  每次全量拷贝  │  每次全量拷贝  │  只需添加时拷贝一次          │
│  事件查找       │  O(n) 遍历     │  O(n) 遍历     │  O(1) 回调通知               │
│  返回后处理     │  遍历所有fd    │  遍历所有fd    │  只遍历就绪fd                │
│  时间复杂度     │  O(n)          │  O(n)          │  O(1) 或 O(k), k为就绪数     │
│  触发模式       │  LT            │  LT            │  LT + ET                     │
│  跨平台         │  是            │  是            │  否 (Linux特有)              │
└─────────────────┴────────────────┴────────────────┴──────────────────────────────┘

性能对比 (1000个连接，100个活跃):
Select/Poll: 每次检查1000个fd
Epoll: 只处理100个活跃fd
```

---

## 六、面试回答

### 30秒版本

> **Select**：使用位图存储 fd，最大 1024 个，每次调用需要拷贝整个 fd_set，时间复杂度 O(n)。
>
> **Poll**：使用数组存储 pollfd，没有数量限制，但仍需每次拷贝和遍历，复杂度 O(n)。
>
> **Epoll**：Linux 特有，使用红黑树存储 fd，就绪链表存储就绪事件。只需添加时拷贝一次，事件驱动通知，只返回就绪 fd，复杂度 O(1)。

### 1分钟版本

> **Select 的问题：**
> - fd 数量限制 1024
> - 每次调用都要拷贝 fd_set 到内核
> - 内核需要遍历所有 fd 检查状态
> - 返回后用户还要遍历找出就绪的 fd
>
> **Poll 的改进：**
> - 使用数组替代位图，没有 1024 限制
> - 但仍然需要每次拷贝和遍历
>
> **Epoll 的突破：**
> - 使用红黑树在内核维护 fd 集合，只需添加时拷贝一次
> - 使用就绪链表存储就绪的 fd
> - 事件驱动，fd 就绪时通过回调加入就绪链表
> - `epoll_wait` 只返回就绪的 fd，无需遍历所有
> - 支持 ET 边缘触发模式，效率更高
>
> **适用场景：**
> - 连接数少：三者差别不大
> - 连接数多但活跃少：Epoll 优势明显（如长连接服务器）
> - 跨平台：只能用 Select/Poll

---

## 七、Java 中的对应

```java
/**
 * Java NIO Selector 底层使用 epoll (Linux)
 */
public class JavaSelectorExample {
    public static void main(String[] args) throws IOException {
        // Selector 底层对应 epoll_create
        Selector selector = Selector.open();
        
        ServerSocketChannel serverChannel = ServerSocketChannel.open();
        serverChannel.bind(new InetSocketAddress(8080));
        serverChannel.configureBlocking(false);
        
        // 注册事件，对应 epoll_ctl ADD
        serverChannel.register(selector, SelectionKey.OP_ACCEPT);
        
        while (true) {
            // 对应 epoll_wait，只返回就绪的 channel
            int readyCount = selector.select();
            if (readyCount == 0) continue;
            
            Set<SelectionKey> selectedKeys = selector.selectedKeys();
            Iterator<SelectionKey> iter = selectedKeys.iterator();
            
            while (iter.hasNext()) {
                SelectionKey key = iter.next();
                iter.remove();
                
                if (key.isAcceptable()) {
                    // 处理新连接
                } else if (key.isReadable()) {
                    // 处理可读事件
                }
            }
        }
    }
}
```
