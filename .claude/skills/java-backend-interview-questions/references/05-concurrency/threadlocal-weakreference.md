# ThreadLocal 为什么使用弱引用

> 分类: Java 并发 | 难度: ⭐⭐⭐⭐ | 频率: 高频

---

## 一、ThreadLocal 结构

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          ThreadLocal 存储结构                                     │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   ┌─────────────────────┐                                                        │
│   │       Thread        │                                                        │
│   │  ┌───────────────┐  │                                                        │
│   │  │ threadLocals  │──┼──────────────────────────────────────────────────────┐ │
│   │  └───────────────┘  │                                                      │ │
│   └─────────────────────┘                                                      │ │
│                                                                                │ │
│   ┌────────────────────────────────────────────────────────────────────────┐   │ │
│   │                         ThreadLocalMap                                  │←──┘ │
│   │  ┌───────────────────────────────────────────────────────────────────┐ │     │
│   │  │                     Entry[] table                                  │ │     │
│   │  │  ┌──────────────┬──────────────┬──────────────┬──────────────┐    │ │     │
│   │  │  │   Entry[0]   │   Entry[1]   │   Entry[2]   │     ...      │    │ │     │
│   │  │  └──────────────┴──────────────┴──────────────┴──────────────┘    │ │     │
│   │  └───────────────────────────────────────────────────────────────────┘ │     │
│   │                                                                         │     │
│   │   Entry 结构:                                                           │     │
│   │   ┌─────────────────────────────────────────────────────────────┐      │     │
│   │   │  class Entry extends WeakReference<ThreadLocal<?>> {        │      │     │
│   │   │      Object value;  // 强引用                                │      │     │
│   │   │  }                                                           │      │     │
│   │   │                                                              │      │     │
│   │   │  key (ThreadLocal) ─→ 弱引用                                 │      │     │
│   │   │  value (存储的值) ─→ 强引用                                  │      │     │
│   │   └─────────────────────────────────────────────────────────────┘      │     │
│   └─────────────────────────────────────────────────────────────────────────┘     │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 二、引用关系图

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          引用关系                                                 │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   栈                       堆                                                    │
│   ┌──────────────┐         ┌──────────────────────┐                             │
│   │              │  强引用  │                      │                             │
│   │ threadLocal ─┼────────→│  ThreadLocal 对象    │←────┐                        │
│   │              │         │                      │     │ 弱引用                 │
│   └──────────────┘         └──────────────────────┘     │                        │
│                                                         │                        │
│   ┌──────────────┐         ┌──────────────────────┐     │                        │
│   │              │  强引用  │                      │     │                        │
│   │   Thread    ─┼────────→│   Thread 对象        │     │                        │
│   │              │         │  ┌────────────────┐  │     │                        │
│   └──────────────┘         │  │ threadLocals ──┼──┼─────┼───┐                    │
│                            │  └────────────────┘  │     │   │                    │
│                            └──────────────────────┘     │   │                    │
│                                                         │   │                    │
│                            ┌──────────────────────────┐ │   │                    │
│                            │   ThreadLocalMap         │←┘   │                    │
│                            │  ┌──────────────────┐    │     │ 强引用             │
│                            │  │      Entry       │    │     │                    │
│                            │  │ ┌──────────────┐ │    │     │                    │
│                            │  │ │ key (弱引用) ─┼─┼────┘     │                    │
│                            │  │ └──────────────┘ │    │     │                    │
│                            │  │ ┌──────────────┐ │    │     │                    │
│                            │  │ │ value(强引用)─┼─┼──→ Value │                    │
│                            │  │ └──────────────┘ │    │                          │
│                            │  └──────────────────┘    │                          │
│                            └──────────────────────────┘                          │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 三、为什么用弱引用

### 3.1 如果使用强引用

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                    假设 Entry.key 使用强引用                                      │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  场景: threadLocal = null (用户希望 ThreadLocal 对象被回收)                       │
│                                                                                  │
│   栈                           堆                                                │
│   ┌──────────────┐             ┌──────────────────────┐                         │
│   │              │    ❌        │                      │                         │
│   │ threadLocal ─┼───×────────→│  ThreadLocal 对象    │←──────┐                  │
│   │   = null     │             │                      │       │ 强引用           │
│   └──────────────┘             └──────────────────────┘       │                  │
│                                                               │                  │
│                                ┌────────────────────────────┐ │                  │
│                                │        Entry               │ │                  │
│                                │  ┌───────────────────────┐ │ │                  │
│                                │  │ key (强引用) ─────────┼─┼─┘                  │
│                                │  └───────────────────────┘ │                    │
│                                │  ┌───────────────────────┐ │                    │
│                                │  │ value (强引用)        │ │                    │
│                                │  └───────────────────────┘ │                    │
│                                └────────────────────────────┘                    │
│                                                                                  │
│  问题: 虽然栈中的引用置为 null，但 Entry.key 强引用着 ThreadLocal 对象            │
│        → ThreadLocal 对象无法被 GC 回收                                          │
│        → 只有等 Thread 结束，ThreadLocalMap 被回收，ThreadLocal 才能被回收        │
│        → 如果使用线程池，Thread 长期存活，内存泄漏!                               │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 使用弱引用的效果

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                    Entry.key 使用弱引用 (实际实现)                                │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  场景: threadLocal = null                                                        │
│                                                                                  │
│   栈                           堆                                                │
│   ┌──────────────┐             ┌──────────────────────┐                         │
│   │              │    ❌        │                      │                         │
│   │ threadLocal ─┼───×────────→│  ThreadLocal 对象    │←┈┈┈┈┐                    │
│   │   = null     │             │  (只有弱引用指向)     │     ┊ 弱引用            │
│   └──────────────┘             └──────────────────────┘     ┊                    │
│                                        ↓ GC 时被回收        ┊                    │
│                                       null                  ┊                    │
│                                                             ┊                    │
│                                ┌────────────────────────────┼──┐                 │
│                                │        Entry               ┊  │                 │
│                                │  ┌───────────────────────┐ ┊  │                 │
│                                │  │ key (弱引用) ─────────┼─┘  │                 │
│                                │  │     → null (GC后)     │    │                 │
│                                │  └───────────────────────┘    │                 │
│                                │  ┌───────────────────────┐    │                 │
│                                │  │ value (强引用)        │    │ ← 仍然存在!      │
│                                │  └───────────────────────┘    │                 │
│                                └───────────────────────────────┘                 │
│                                                                                  │
│  优点: ThreadLocal 对象可以被 GC 回收                                            │
│  遗留问题: Entry.value 仍然存在，这就是"内存泄漏"的根源                           │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 四、内存泄漏问题

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                    内存泄漏分析                                                   │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  ThreadLocal 被回收后:                                                           │
│                                                                                  │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │   Entry[0]  │   Entry[1]  │   Entry[2]  │   Entry[3]  │   Entry[4]  │ ... │ │
│  │  ┌───┬───┐  │  ┌───┬───┐  │  ┌───┬───┐  │  ┌───┬───┐  │  ┌───┬───┐  │     │ │
│  │  │key│val│  │  │key│val│  │  │key│val│  │  │key│val│  │  │key│val│  │     │ │
│  │  │ ↓ │ ↓ │  │  │ ↓ │ ↓ │  │  │ ↓ │ ↓ │  │  │ ↓ │ ↓ │  │  │ ↓ │ ↓ │  │     │ │
│  │  │TL1│V1 │  │  │null│V2│  │  │TL3│V3 │  │  │null│V4│  │  │TL5│V5 │  │     │ │
│  │  └───┴───┘  │  └───┴───┘  │  └───┴───┘  │  └───┴───┘  │  └───┴───┘  │     │ │
│  └─────────────┴─────────────┴─────────────┴─────────────┴─────────────┴─────┘ │
│                       ↑                           ↑                             │
│                  key=null                    key=null                           │
│                  value 还在!                  value 还在!                        │
│                  (内存泄漏)                   (内存泄漏)                          │
│                                                                                  │
│  这些 key=null 的 Entry 称为 "stale entry" (陈旧条目)                            │
│  value 无法被访问，但也无法被回收                                                │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

### 4.1 ThreadLocal 的自清理机制

```java
/**
 * ThreadLocal.get() 源码片段
 */
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            return (T)e.value;
        }
    }
    return setInitialValue();
}

// getEntry 会触发 expungeStaleEntry (清理陈旧条目)
private Entry getEntry(ThreadLocal<?> key) {
    int i = key.threadLocalHashCode & (table.length - 1);
    Entry e = table[i];
    if (e != null && e.get() == key)
        return e;
    else
        return getEntryAfterMiss(key, i, e);  // 这里会清理 key=null 的 Entry
}

/**
 * set() 和 remove() 也会触发清理
 */
```

### 4.2 为什么仍有泄漏风险

```
自清理机制的局限:
• 只在 get/set/remove 时触发清理
• 如果之后再也不调用这些方法，陈旧条目永远不会被清理
• 线程池场景下，线程长期存活，问题更严重
```

---

## 五、最佳实践

```java
/**
 * ✅ 正确使用方式
 */
public class ThreadLocalBestPractice {
    
    // 1. 建议声明为 static final
    private static final ThreadLocal<User> userHolder = new ThreadLocal<>();
    
    public void processRequest(User user) {
        try {
            // 2. 使用前设置
            userHolder.set(user);
            
            // 业务处理...
            doSomething();
            
        } finally {
            // 3. 使用后必须 remove
            userHolder.remove();  // 重要!
        }
    }
    
    private void doSomething() {
        User user = userHolder.get();
        // 使用 user...
    }
}
```

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          最佳实践总结                                             │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  1. 使用完毕必须调用 remove()                                                    │
│     ┌─────────────────────────────────────────────────────────────────────────┐ │
│     │  try {                                                                   │ │
│     │      threadLocal.set(value);                                             │ │
│     │      // 业务代码                                                         │ │
│     │  } finally {                                                             │ │
│     │      threadLocal.remove();  // 关键!                                     │ │
│     │  }                                                                       │ │
│     └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
│  2. 声明为 static final                                                          │
│     • 避免重复创建 ThreadLocal 实例                                              │
│     • 一个 ThreadLocal 对象对应一种上下文数据                                    │
│                                                                                  │
│  3. 线程池场景要特别注意                                                         │
│     • 线程会被复用                                                               │
│     • 上一个任务的 ThreadLocal 值可能被下一个任务读到                            │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 六、面试回答

### 30秒版本

> ThreadLocal 的 Entry 对 key 使用弱引用，是为了让 ThreadLocal 对象在外部没有强引用时可以被 GC 回收。
>
> 如果用强引用，当 `threadLocal = null` 后，ThreadLocal 对象仍被 Entry.key 强引用，无法回收，造成内存泄漏。
>
> 但弱引用只解决了 key 的回收问题，value 仍然是强引用，仍有泄漏风险。所以**使用完必须调用 remove()**。

### 1分钟版本

> **ThreadLocal 结构**：
> 每个 Thread 有一个 ThreadLocalMap，Entry 数组存储数据。Entry 继承 WeakReference，key 是对 ThreadLocal 的弱引用，value 是强引用。
>
> **为什么用弱引用**：
> 当我们 `threadLocal = null` 时，如果 Entry.key 是强引用，ThreadLocal 对象永远无法被回收（被 Entry 强引用着）。使用弱引用后，当 ThreadLocal 只剩弱引用时，GC 可以回收它。
>
> **内存泄漏问题**：
> 弱引用解决了 key 的回收，但 value 仍是强引用。当 key 被回收后，Entry 变成 (null, value)，value 无法被访问却也无法被回收——这就是内存泄漏。
>
> **解决方案**：
> 1. ThreadLocal 在 get/set/remove 时会清理 key=null 的 Entry
> 2. 最佳实践：用完后在 finally 块中调用 remove()
> 3. 特别注意线程池场景，线程复用可能读到旧值

---

## 七、源码分析

```java
/**
 * ThreadLocalMap.Entry 源码
 */
static class Entry extends WeakReference<ThreadLocal<?>> {
    Object value;
    
    Entry(ThreadLocal<?> k, Object v) {
        super(k);  // key 是弱引用
        value = v; // value 是强引用
    }
}

/**
 * remove 方法
 */
public void remove() {
    ThreadLocalMap m = getMap(Thread.currentThread());
    if (m != null)
        m.remove(this);
}

// ThreadLocalMap.remove
private void remove(ThreadLocal<?> key) {
    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode & (len-1);
    for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) {
        if (e.get() == key) {
            e.clear();  // 清除弱引用
            expungeStaleEntry(i);  // 清理陈旧条目，包括 value
            return;
        }
    }
}
```
