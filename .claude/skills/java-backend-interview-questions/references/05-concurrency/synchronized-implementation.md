# Java 的 synchronized 是怎么实现的？

## 概念解析

**synchronized** 是 Java 的内置锁机制，基于 **Monitor（监视器锁）** 实现，在 JVM 层面保证线程同步。

```
┌─────────────────────────────────────────────────────────────┐
│                 synchronized 实现层次                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │                   Java 源码                         │  │
│   │    synchronized(obj) { ... }                        │  │
│   └─────────────────────────────────────────────────────┘  │
│                          ↓ 编译                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │                   字节码                            │  │
│   │    monitorenter  /  monitorexit                     │  │
│   └─────────────────────────────────────────────────────┘  │
│                          ↓ 执行                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │                   JVM 层                            │  │
│   │    对象头 Mark Word + Monitor 对象                   │  │
│   └─────────────────────────────────────────────────────┘  │
│                          ↓ 底层                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │                   操作系统                          │  │
│   │    Mutex Lock (互斥锁) + 线程调度                    │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 对象内存布局

```
┌─────────────────────────────────────────────────────────────┐
│                   Java 对象内存结构                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │                  对象头 (Object Header)              │  │
│   │  ┌───────────────────────────────────────────────┐  │  │
│   │  │  Mark Word (64 bit)                           │  │  │
│   │  │  ├── 锁状态信息                                │  │  │
│   │  │  ├── hashCode                                 │  │  │
│   │  │  ├── GC 分代年龄                               │  │  │
│   │  │  └── 锁标志位                                  │  │  │
│   │  └───────────────────────────────────────────────┘  │  │
│   │  ┌───────────────────────────────────────────────┐  │  │
│   │  │  Class Pointer (32/64 bit)                    │  │  │
│   │  │  └── 指向类元数据                              │  │  │
│   │  └───────────────────────────────────────────────┘  │  │
│   │  ┌───────────────────────────────────────────────┐  │  │
│   │  │  Array Length (可选，数组对象才有)              │  │  │
│   │  └───────────────────────────────────────────────┘  │  │
│   └─────────────────────────────────────────────────────┘  │
│   ┌─────────────────────────────────────────────────────┐  │
│   │                  实例数据 (Instance Data)           │  │
│   └─────────────────────────────────────────────────────┘  │
│   ┌─────────────────────────────────────────────────────┐  │
│   │                  对齐填充 (Padding)                 │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## Mark Word 详解

```
┌─────────────────────────────────────────────────────────────┐
│              64 位 HotSpot VM Mark Word 结构                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   无锁状态:                                                  │
│   ┌──────────────────────────────────────────────────────┐ │
│   │ unused(25) │ hashCode(31) │ unused(1) │ age(4) │ 0│01│ │
│   └──────────────────────────────────────────────────────┘ │
│                                                             │
│   偏向锁:                                                    │
│   ┌──────────────────────────────────────────────────────┐ │
│   │ threadId(54)    │ epoch(2) │ unused(1) │ age(4) │ 1│01│ │
│   └──────────────────────────────────────────────────────┘ │
│                                                             │
│   轻量级锁:                                                  │
│   ┌──────────────────────────────────────────────────────┐ │
│   │         Lock Record 指针 (62 bit)              │  00  │ │
│   └──────────────────────────────────────────────────────┘ │
│                                                             │
│   重量级锁:                                                  │
│   ┌──────────────────────────────────────────────────────┐ │
│   │         Monitor 指针 (62 bit)                  │  10  │ │
│   └──────────────────────────────────────────────────────┘ │
│                                                             │
│   GC 标记:                                                   │
│   ┌──────────────────────────────────────────────────────┐ │
│   │                                                │  11  │ │
│   └──────────────────────────────────────────────────────┘ │
│                                                             │
│   锁标志位: 01=无锁/偏向锁, 00=轻量锁, 10=重量锁, 11=GC标记   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 锁升级过程

```
┌─────────────────────────────────────────────────────────────┐
│                      锁升级过程                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌─────────┐    ┌─────────┐    ┌─────────┐    ┌─────────┐ │
│   │  无锁   │ ──→│ 偏向锁  │ ──→│ 轻量锁  │ ──→│ 重量锁  │ │
│   └─────────┘    └─────────┘    └─────────┘    └─────────┘ │
│       │              │              │              │       │
│       ▼              ▼              ▼              ▼       │
│    无竞争         单线程         轻度竞争       激烈竞争     │
│                  反复获取        CAS 自旋      OS 互斥锁    │
│                                                             │
│   注意: 锁只能升级，不能降级（偏向锁可以被撤销）              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 1. 偏向锁 (Biased Locking)

```
┌─────────────────────────────────────────────────────────────┐
│                       偏向锁原理                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   场景：锁总是由同一线程持有，没有竞争                        │
│                                                             │
│   ┌─────────────┐                                           │
│   │   Thread A  │                                           │
│   │  ┌───────┐  │     ┌──────────────────────────────┐     │
│   │  │  代码  │  │     │          对象头              │     │
│   │  │ sync{} │  │ ──→ │  threadId = Thread A        │     │
│   │  └───────┘  │     │  锁标志 = 101 (偏向)          │     │
│   └─────────────┘     └──────────────────────────────┘     │
│                                                             │
│   第一次: CAS 设置 threadId                                  │
│   后续: 只检查 threadId 是否匹配，无需 CAS                   │
│                                                             │
│   优点: 加锁解锁无额外开销，和无锁执行性能接近                 │
│                                                             │
│   JDK 15 默认禁用偏向锁 (-XX:-UseBiasedLocking)              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2. 轻量级锁 (Lightweight Lock)

```
┌─────────────────────────────────────────────────────────────┐
│                     轻量级锁原理                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   场景：多线程交替执行，竞争不激烈                           │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │                    线程栈帧                         │  │
│   │  ┌───────────────────────────────────────────────┐  │  │
│   │  │  Lock Record (锁记录)                         │  │  │
│   │  │  ├── Displaced Mark Word (保存原 Mark Word)   │  │  │
│   │  │  └── Owner (指向对象头)                       │  │  │
│   │  └───────────────────────────────────────────────┘  │  │
│   └─────────────────────────────────────────────────────┘  │
│                        ↕ CAS                                │
│   ┌─────────────────────────────────────────────────────┐  │
│   │                    对象头                           │  │
│   │  ┌───────────────────────────────────────────────┐  │  │
│   │  │  Mark Word = Lock Record 指针 + 00            │  │  │
│   │  └───────────────────────────────────────────────┘  │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   加锁: CAS 将 Mark Word 替换为 Lock Record 指针            │
│   解锁: CAS 将 Displaced Mark Word 还原                     │
│   竞争: CAS 失败则自旋重试，自旋超过阈值则膨胀为重量级锁      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 3. 重量级锁 (Heavyweight Lock)

```
┌─────────────────────────────────────────────────────────────┐
│                    重量级锁原理                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   场景：多线程竞争激烈                                       │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │                 ObjectMonitor (C++ 对象)            │  │
│   │  ┌───────────────────────────────────────────────┐  │  │
│   │  │  _owner       = 持有锁的线程                   │  │  │
│   │  │  _count       = 重入计数                       │  │  │
│   │  │  _EntryList   = 等待获取锁的线程 (阻塞队列)     │  │  │
│   │  │  _WaitSet     = 调用 wait() 的线程 (等待队列)   │  │  │
│   │  │  _recursions  = 重入次数                       │  │  │
│   │  └───────────────────────────────────────────────┘  │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │                                                     │  │
│   │   Thread 1 (持有锁)                                 │  │
│   │       ↓                                             │  │
│   │   ┌─────────┐                                       │  │
│   │   │ Monitor │ ← _owner = Thread 1                   │  │
│   │   └─────────┘                                       │  │
│   │       ↑                                             │  │
│   │   ┌─────────────────────────────┐                   │  │
│   │   │  _EntryList                 │                   │  │
│   │   │  [Thread2] [Thread3] ...    │  ← 阻塞等待       │  │
│   │   └─────────────────────────────┘                   │  │
│   │                                                     │  │
│   │   ┌─────────────────────────────┐                   │  │
│   │   │  _WaitSet                   │                   │  │
│   │   │  [Thread4] [Thread5] ...    │  ← wait() 等待    │  │
│   │   └─────────────────────────────┘                   │  │
│   │                                                     │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   涉及用户态 ↔ 内核态切换，开销大                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 字节码层面

```java
public class SyncDemo {
    private int count = 0;
    
    // 同步方法
    public synchronized void increment() {
        count++;
    }
    
    // 同步代码块
    public void incrementBlock() {
        synchronized (this) {
            count++;
        }
    }
}
```

```
// javap -v SyncDemo.class

// 同步方法：通过 flags 中的 ACC_SYNCHRONIZED 标志
public synchronized void increment();
  flags: ACC_PUBLIC, ACC_SYNCHRONIZED  // 关键标志
  Code:
    // ...方法体

// 同步代码块：通过 monitorenter/monitorexit 指令
public void incrementBlock();
  Code:
     0: aload_0
     1: dup
     2: astore_1
     3: monitorenter        // 进入同步
     4: aload_0
     5: dup
     6: getfield      #2    // Field count:I
     9: iconst_1
    10: iadd
    11: putfield      #2    // Field count:I
    14: aload_1
    15: monitorexit         // 正常退出
    16: goto          24
    19: astore_2
    20: aload_1
    21: monitorexit         // 异常退出（保证锁释放）
    22: aload_2
    23: athrow
    24: return
```

## JVM 锁优化

```
┌─────────────────────────────────────────────────────────────┐
│                     JVM 锁优化技术                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. 自旋锁 (Spin Lock)                                     │
│      └── 获取锁失败时不立即阻塞，循环尝试                     │
│      └── 适合锁持有时间短的场景                              │
│      └── -XX:PreBlockSpin (默认10次)                        │
│                                                             │
│   2. 自适应自旋                                              │
│      └── 根据上次自旋结果动态调整自旋次数                     │
│      └── 上次成功 → 增加自旋次数                             │
│      └── 上次失败 → 减少或跳过自旋                           │
│                                                             │
│   3. 锁消除 (Lock Elimination)                              │
│      └── JIT 逃逸分析，消除不可能存在竞争的锁                 │
│      └── 例如：局部变量 StringBuffer 的同步                  │
│                                                             │
│   4. 锁粗化 (Lock Coarsening)                               │
│      └── 连续多次加锁解锁合并为一次                          │
│      └── 例如：循环内部的同步扩展到循环外                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

```java
// 锁消除示例
public String concat(String s1, String s2) {
    // StringBuffer 是同步的，但 sb 不会逃逸，JIT 会消除锁
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    return sb.toString();
}

// 锁粗化示例
public void loopSync() {
    for (int i = 0; i < 100; i++) {
        synchronized (this) {  // 100 次加锁解锁
            // ...
        }
    }
}
// JIT 优化后
public void loopSync() {
    synchronized (this) {  // 合并为 1 次
        for (int i = 0; i < 100; i++) {
            // ...
        }
    }
}
```

## 相关 JVM 参数

```bash
# 偏向锁相关
-XX:+UseBiasedLocking         # 启用偏向锁（JDK 15 前默认开启）
-XX:BiasedLockingStartupDelay=0  # 偏向锁启动延迟（默认4秒）

# 自旋锁相关
-XX:PreBlockSpin=10           # 自旋次数

# 锁消除
-XX:+DoEscapeAnalysis         # 逃逸分析（默认开启）
-XX:+EliminateLocks           # 锁消除（默认开启）

# 锁膨胀阈值
-XX:+PrintSynchronizedLockContentionTime  # 打印锁竞争信息
```

## 面试回答

### 30秒版本

> synchronized 基于 **对象头 Mark Word + Monitor** 实现。JVM 做了锁升级优化：无锁 → 偏向锁（单线程无竞争）→ 轻量级锁（CAS 自旋）→ 重量级锁（OS 互斥锁）。此外还有锁消除（JIT 逃逸分析）、锁粗化、自适应自旋等优化。

### 1分钟版本

> **实现层次**：
> - 源码：synchronized 关键字
> - 字节码：monitorenter / monitorexit 指令
> - JVM：对象头 Mark Word + ObjectMonitor
> - OS：Mutex Lock 互斥锁
>
> **对象头 Mark Word**：64 位，存储锁状态、hashCode、GC年龄、锁标志位。
>
> **锁升级（不可降级）**：
> 1. **偏向锁**：记录线程 ID，同一线程反复获取无需 CAS
> 2. **轻量级锁**：CAS 竞争，失败则自旋重试
> 3. **重量级锁**：ObjectMonitor，线程阻塞（用户态↔内核态切换）
>
> **JVM 优化**：锁消除（逃逸分析）、锁粗化（合并连续加锁）、自适应自旋。
>
> **注意**：JDK 15 默认禁用偏向锁（维护成本 > 收益）。

---

*关联文档：[synchronized-vs-reentrantlock.md](synchronized-vs-reentrantlock.md) | [lock-optimization.md](lock-optimization.md) | [aqs.md](aqs.md)*
