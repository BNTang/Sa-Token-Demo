# Java 内存模型 (JMM)

> 分类: Java 并发 | 难度: ⭐⭐⭐⭐⭐ | 频率: 高频

---

## 一、什么是 JMM

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                    Java Memory Model (JMM)                                        │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  定义: JMM 是一种规范，定义了 Java 程序中多线程之间如何通过内存进行交互            │
│                                                                                  │
│  解决的问题:                                                                     │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │  1. 可见性: 一个线程对共享变量的修改，其他线程能否立即看到                   │ │
│  │  2. 有序性: 代码执行顺序是否和书写顺序一致                                  │ │
│  │  3. 原子性: 操作是否不可分割                                                │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
│  为什么需要 JMM?                                                                 │
│  - CPU 多级缓存导致可见性问题                                                    │
│  - 编译器/CPU 指令重排序导致有序性问题                                           │
│  - 线程切换导致原子性问题                                                        │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 二、JMM 内存结构

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          JMM 抽象内存模型                                         │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│     线程A                                                    线程B               │
│   ┌─────────────┐                                      ┌─────────────┐          │
│   │  本地内存    │                                      │  本地内存    │          │
│   │ (工作内存)  │                                      │ (工作内存)  │          │
│   │             │                                      │             │          │
│   │ 共享变量副本│                                      │ 共享变量副本│          │
│   │   x = 1     │                                      │   x = 0     │          │
│   └──────┬──────┘                                      └──────┬──────┘          │
│          │                                                    │                  │
│          │  读取/写入                                读取/写入 │                  │
│          │                                                    │                  │
│          ↓                                                    ↓                  │
│   ┌─────────────────────────────────────────────────────────────────────────┐   │
│   │                            主内存 (Main Memory)                          │   │
│   │                                                                          │   │
│   │                            共享变量 x = ?                                │   │
│   │                                                                          │   │
│   └─────────────────────────────────────────────────────────────────────────┘   │
│                                                                                  │
│   问题: 线程A修改了x，线程B可能看不到                                            │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

### 2.1 内存交互操作

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          8种内存交互操作                                          │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   主内存操作:                                                                    │
│   ┌──────────────────────────────────────────────────────────────────────────┐  │
│   │  lock    : 把变量标识为线程独占                                           │  │
│   │  unlock  : 释放锁定状态                                                   │  │
│   │  read    : 把变量值从主内存传输到工作内存                                 │  │
│   │  write   : 把工作内存的值写入主内存                                       │  │
│   └──────────────────────────────────────────────────────────────────────────┘  │
│                                                                                  │
│   工作内存操作:                                                                  │
│   ┌──────────────────────────────────────────────────────────────────────────┐  │
│   │  load    : 把read得到的值放入工作内存的变量副本                           │  │
│   │  use     : 把工作内存的值传递给执行引擎                                   │  │
│   │  assign  : 把执行引擎的值赋给工作内存变量                                 │  │
│   │  store   : 把工作内存的值传送到主内存                                     │  │
│   └──────────────────────────────────────────────────────────────────────────┘  │
│                                                                                  │
│   变量从主内存到工作内存: read → load                                            │
│   变量从工作内存到主内存: store → write                                          │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 三、happens-before 规则

JMM 通过 happens-before 规则来定义操作之间的可见性和有序性。

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          happens-before 规则                                      │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  含义: 如果操作A happens-before 操作B，则:                                       │
│        1. A的执行结果对B可见                                                     │
│        2. A的执行顺序在B之前(逻辑上)                                             │
│                                                                                  │
│  8条规则:                                                                        │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                            │ │
│  │  1. 程序顺序规则                                                           │ │
│  │     同一线程内，前面的操作 happens-before 后面的操作                        │ │
│  │                                                                            │ │
│  │  2. 监视器锁规则                                                           │ │
│  │     unlock操作 happens-before 后续的lock操作                               │ │
│  │                                                                            │ │
│  │  3. volatile规则                                                           │ │
│  │     volatile写 happens-before 后续的volatile读                             │ │
│  │                                                                            │ │
│  │  4. 线程启动规则                                                           │ │
│  │     Thread.start() happens-before 线程中的任何操作                         │ │
│  │                                                                            │ │
│  │  5. 线程终止规则                                                           │ │
│  │     线程中的任何操作 happens-before Thread.join()返回                      │ │
│  │                                                                            │ │
│  │  6. 线程中断规则                                                           │ │
│  │     interrupt() happens-before 被中断线程检测到中断                        │ │
│  │                                                                            │ │
│  │  7. 对象终结规则                                                           │ │
│  │     构造函数执行完成 happens-before finalize()                             │ │
│  │                                                                            │ │
│  │  8. 传递性规则                                                             │ │
│  │     A hb B，B hb C  →  A hb C                                              │ │
│  │                                                                            │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

### 3.1 规则应用示例

```java
/**
 * volatile 规则示例
 */
public class VolatileHappensBeforeExample {
    private int a = 0;
    private volatile boolean flag = false;
    
    // 线程A
    public void writer() {
        a = 1;          // 1
        flag = true;    // 2 (volatile写)
    }
    
    // 线程B
    public void reader() {
        if (flag) {     // 3 (volatile读)
            int i = a;  // 4
            // 保证读到 a = 1
        }
    }
}

/**
 * happens-before 分析:
 * 1 hb 2 (程序顺序规则)
 * 2 hb 3 (volatile规则: volatile写 hb volatile读)
 * 3 hb 4 (程序顺序规则)
 * 由传递性: 1 hb 4
 * 所以: 操作4一定能看到操作1的结果
 */
```

```java
/**
 * synchronized 规则示例
 */
public class SynchronizedHappensBeforeExample {
    private int value = 0;
    
    public synchronized void setValue(int v) {
        value = v;  // 在锁释放前执行
    }  // unlock
    
    public synchronized int getValue() {  // lock
        return value;  // 一定能看到之前的修改
    }
}
```

---

## 四、内存屏障

JMM 通过内存屏障来实现 happens-before 规则。

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          内存屏障类型                                             │
├─────────────────┬────────────────────────────────────────────────────────────────┤
│   屏障类型      │                      作用                                       │
├─────────────────┼────────────────────────────────────────────────────────────────┤
│  LoadLoad       │  确保Load1数据的装载先于Load2及后续装载                        │
│  StoreStore     │  确保Store1数据对其他处理器可见先于Store2及后续存储            │
│  LoadStore      │  确保Load1数据装载先于Store2及后续存储刷新到主内存             │
│  StoreLoad      │  确保Store1数据刷新到主内存先于Load2及后续装载                 │
└─────────────────┴────────────────────────────────────────────────────────────────┘
```

### 4.1 volatile 的内存屏障

```
volatile写操作:
┌─────────────────────────────────────────────────────────────────┐
│  普通写                                                          │
│  [StoreStore屏障]  ← 禁止上面的普通写与下面的volatile写重排序   │
│  volatile写                                                      │
│  [StoreLoad屏障]   ← 禁止volatile写与下面的volatile读/写重排序  │
└─────────────────────────────────────────────────────────────────┘

volatile读操作:
┌─────────────────────────────────────────────────────────────────┐
│  volatile读                                                      │
│  [LoadLoad屏障]    ← 禁止下面的普通读与上面的volatile读重排序   │
│  [LoadStore屏障]   ← 禁止下面的普通写与上面的volatile读重排序   │
│  普通读/写                                                       │
└─────────────────────────────────────────────────────────────────┘
```

---

## 五、重排序

### 5.1 三种重排序

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          三种重排序                                               │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  源代码                                                                          │
│     ↓                                                                            │
│  ┌────────────────────────────────────────────┐                                  │
│  │          1. 编译器优化重排序               │                                  │
│  │    编译器在不改变单线程语义的前提下重排序   │                                  │
│  └────────────────────────────────────────────┘                                  │
│     ↓                                                                            │
│  ┌────────────────────────────────────────────┐                                  │
│  │          2. 指令级并行重排序               │                                  │
│  │    CPU采用指令级并行技术(ILP)重排指令     │                                  │
│  └────────────────────────────────────────────┘                                  │
│     ↓                                                                            │
│  ┌────────────────────────────────────────────┐                                  │
│  │          3. 内存系统重排序                 │                                  │
│  │    由于缓存/读写缓冲区，导致顺序不一致     │                                  │
│  └────────────────────────────────────────────┘                                  │
│     ↓                                                                            │
│  最终执行顺序                                                                    │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

### 5.2 数据依赖性

```java
// 有数据依赖，不能重排序
int a = 1;      // 1
int b = a + 1;  // 2 (依赖a)
// 1必须在2之前执行

// 无数据依赖，可能重排序
int a = 1;  // 1
int b = 2;  // 2
// 1和2可能被重排序
```

### 5.3 as-if-serial 语义

```
编译器和处理器保证: 
不管怎么重排序，单线程程序的执行结果不能被改变

这就是 as-if-serial 语义
```

---

## 六、代码示例

### 6.1 双重检查锁定 (DCL)

```java
/**
 * 双重检查锁定单例 - 需要 volatile
 */
public class Singleton {
    // 必须用 volatile 禁止重排序
    private static volatile Singleton instance;
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (instance == null) {                    // 第一次检查
            synchronized (Singleton.class) {
                if (instance == null) {            // 第二次检查
                    instance = new Singleton();    // 问题所在
                    // new 操作分三步:
                    // 1. 分配内存空间
                    // 2. 初始化对象
                    // 3. 将引用指向内存空间
                    // 可能重排序为 1 → 3 → 2
                    // 导致其他线程看到未初始化的对象
                }
            }
        }
        return instance;
    }
}
```

### 6.2 正确的发布对象

```java
/**
 * 使用 volatile 正确发布对象
 */
public class SafePublication {
    private volatile Config config;
    
    public void updateConfig(Config newConfig) {
        // volatile写保证:
        // 1. newConfig的所有字段初始化完成
        // 2. 然后才将引用写入config
        this.config = newConfig;
    }
    
    public Config getConfig() {
        return config;  // volatile读保证看到完整的对象
    }
}
```

---

## 七、面试回答

### 30秒版本

> JMM (Java Memory Model) 是 Java 内存模型，定义了多线程如何通过内存交互。
>
> 核心要点：
> 1. 每个线程有**工作内存**（缓存），共享变量存放在**主内存**
> 2. 通过 **happens-before** 规则定义可见性和有序性
> 3. volatile/synchronized/Lock 等通过**内存屏障**实现 happens-before
> 4. 编译器和 CPU 可能进行**指令重排序**，JMM 限制重排序保证正确性

### 1分钟版本

> **JMM 是什么：**
> Java 内存模型是一种规范，屏蔽硬件差异，定义了多线程程序中变量的访问规则。
>
> **内存结构：**
> - 主内存：所有线程共享，存放共享变量
> - 工作内存：每个线程私有，存放共享变量的副本
>
> **happens-before 规则：**
> 定义操作间的可见性，主要包括：
> - 程序顺序规则：同一线程前面操作 hb 后面操作
> - volatile 规则：volatile 写 hb 后续的 volatile 读
> - synchronized 规则：unlock hb 后续的 lock
> - 传递性规则
>
> **内存屏障：**
> JVM 通过插入内存屏障实现 happens-before，禁止特定类型的重排序。
>
> **典型问题：**
> DCL 单例模式需要 volatile，因为 new 操作可能被重排序，导致其他线程看到未初始化的对象。

---

## 八、最佳实践

### ✅ 推荐做法

```java
// 1. 状态标志用 volatile
private volatile boolean running = true;

// 2. DCL 单例必须用 volatile
private static volatile Singleton instance;

// 3. 不可变对象使用 final
public final class ImmutableConfig {
    private final String value;
}

// 4. 发布可变对象使用 volatile 或 synchronized
private volatile Config config;

// 5. 复合操作使用 synchronized 或 Lock
public synchronized void transfer(Account from, Account to, int amount) {
    from.decrease(amount);
    to.increase(amount);
}
```

### ❌ 避免做法

```java
// ❌ DCL 不使用 volatile
private static Singleton instance;  // 缺少 volatile

// ❌ 依赖普通变量的可见性
private boolean flag = true;  // 其他线程可能看不到修改

// ❌ volatile 用于复合操作
private volatile int count;
public void increment() {
    count++;  // 不是原子操作!
}
```
