# Java 中 volatile 关键字的作用是什么？

## volatile 核心作用

```
┌─────────────────────────────────────────────────────────────┐
│                    volatile 两大作用                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. 可见性 (Visibility)                                    │
│      └── 一个线程修改后，其他线程立即可见                   │
│                                                             │
│   2. 有序性 (Ordering) / 禁止指令重排                       │
│      └── 禁止编译器和 CPU 对指令重排序                      │
│                                                             │
│   注意: volatile 不保证原子性！                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 可见性问题

```
┌─────────────────────────────────────────────────────────────┐
│                    无 volatile 的问题                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌─────────────┐              ┌─────────────┐             │
│   │  Thread A   │              │  Thread B   │             │
│   └──────┬──────┘              └──────┬──────┘             │
│          │                            │                     │
│          │  ┌─────────────────────────│────────────────┐   │
│          │  │       Main Memory       │                │   │
│          │  │    flag = false         │                │   │
│          │  └─────────────────────────│────────────────┘   │
│          │                            │                     │
│          ▼                            ▼                     │
│   ┌─────────────┐              ┌─────────────┐             │
│   │ CPU Cache A │              │ CPU Cache B │             │
│   │ flag = false│              │ flag = false│             │
│   └─────────────┘              └─────────────┘             │
│          │                            │                     │
│   Thread A 修改                 Thread B 读取               │
│   flag = true                   flag 仍是 false!            │
│   (只在缓存中)                  (看不到修改)                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

```java
// 可见性问题示例
public class VisibilityDemo {
    private boolean flag = false;  // 没有 volatile
    
    public void writer() {
        flag = true;  // 线程 A 修改
    }
    
    public void reader() {
        while (!flag) {
            // 线程 B 可能永远看不到 flag = true
            // 因为读的是自己 CPU 缓存中的旧值
        }
        System.out.println("Done");  // 可能永远执行不到
    }
}
```

## volatile 保证可见性

```
┌─────────────────────────────────────────────────────────────┐
│                    volatile 可见性                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   volatile 变量的读写规则:                                   │
│                                                             │
│   写操作: 写入 volatile 变量                                 │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  1. 将工作内存中的值刷新到主内存                     │  │
│   │  2. 让其他 CPU 缓存中该变量失效                      │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   读操作: 读取 volatile 变量                                 │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  1. 从主内存重新读取最新值                           │  │
│   │  2. 加载到工作内存                                   │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

```java
// 使用 volatile 解决可见性
public class VolatileVisibility {
    private volatile boolean flag = false;  // 加 volatile
    
    public void writer() {
        flag = true;  // 写入后刷新到主内存
    }
    
    public void reader() {
        while (!flag) {
            // 每次都从主内存读取最新值
        }
        System.out.println("Done");  // 能正常执行
    }
}
```

## 禁止指令重排

```
┌─────────────────────────────────────────────────────────────┐
│                    指令重排序问题                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   DCL 单例模式的问题:                                        │
│                                                             │
│   instance = new Singleton(); 这一行代码实际分三步:          │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  1. 分配内存空间                                     │  │
│   │  2. 初始化对象                                       │  │
│   │  3. instance 指向内存地址                            │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   CPU/编译器可能重排为 1 → 3 → 2:                            │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  1. 分配内存空间                                     │  │
│   │  3. instance 指向内存地址 (此时 instance != null)    │  │
│   │  2. 初始化对象 (尚未执行)                            │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   此时另一线程看到 instance != null，直接返回未初始化对象!  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

```java
// 有问题的 DCL 单例
public class Singleton {
    private static Singleton instance;
    
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();  // 可能重排序
                }
            }
        }
        return instance;  // 可能返回未初始化的对象
    }
}

// 正确的 DCL 单例
public class Singleton {
    private static volatile Singleton instance;  // 加 volatile
    
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();  // 禁止重排序
                }
            }
        }
        return instance;
    }
}
```

## volatile 不保证原子性

```java
public class NotAtomicDemo {
    private volatile int count = 0;
    
    public void increment() {
        count++;  // 不是原子操作！
        // count++ 分三步:
        // 1. 读取 count
        // 2. count + 1
        // 3. 写回 count
        // 多线程下仍有问题
    }
    
    // 正确做法: 使用 AtomicInteger
    private AtomicInteger atomicCount = new AtomicInteger(0);
    
    public void atomicIncrement() {
        atomicCount.incrementAndGet();  // 原子操作
    }
}
```

## 使用场景

```
┌─────────────────────────────────────────────────────────────┐
│                    volatile 适用场景                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. 状态标记                                                │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  private volatile boolean running = true;            │  │
│   │                                                     │  │
│   │  public void stop() { running = false; }             │  │
│   │                                                     │  │
│   │  public void run() {                                 │  │
│   │      while (running) { ... }                         │  │
│   │  }                                                   │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   2. 双重检查锁 (DCL) 单例                                  │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  private static volatile Singleton instance;         │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   3. 一写多读场景                                           │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  // 只有一个线程写，多个线程读                       │  │
│   │  private volatile Config config;                     │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   不适用场景:                                                │
│   • 需要原子性的复合操作 (count++)                          │
│   • 多个变量之间需要原子性                                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## volatile vs synchronized

```
┌─────────────────────────────────────────────────────────────┐
│                volatile vs synchronized                     │
├─────────────────┬──────────────────┬────────────────────────┤
│   特性          │   volatile       │   synchronized         │
├─────────────────┼──────────────────┼────────────────────────┤
│   可见性        │   ✓              │   ✓                    │
│   有序性        │   ✓              │   ✓                    │
│   原子性        │   ✗              │   ✓                    │
│   性能          │   高             │   低                   │
│   阻塞          │   不阻塞         │   阻塞                 │
│   适用范围      │   变量           │   代码块/方法          │
├─────────────────┴──────────────────┴────────────────────────┤
│                                                             │
│   volatile 是轻量级同步机制，适合简单场景                    │
│   synchronized 是重量级，功能更强大                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 面试回答

### 30秒版本

> volatile 有两个作用：1）**可见性**：一个线程修改后，其他线程立即可见，每次读都从主内存读取；2）**禁止指令重排**：比如 DCL 单例中防止对象未初始化就被使用。**注意**：volatile 不保证原子性，count++ 这种需要用 AtomicInteger。

### 1分钟版本

> **volatile 两大作用**：
>
> 1. **可见性**：
>    - 写操作：刷新到主内存，使其他缓存失效
>    - 读操作：从主内存读取最新值
>    - 典型场景：状态标记 `volatile boolean running`
>
> 2. **禁止指令重排**：
>    - 防止编译器和 CPU 重排序
>    - 典型场景：DCL 单例，防止返回未初始化对象
>
> **不保证原子性**：
> - `count++` 是读-改-写三步操作
> - 多线程下仍有问题
> - 需要用 `AtomicInteger` 或 `synchronized`
>
> **适用场景**：
> - 状态标记
> - 一写多读
> - DCL 单例

---

*关联文档：[synchronized.md](synchronized.md) | [thread-lifecycle.md](thread-lifecycle.md)*
