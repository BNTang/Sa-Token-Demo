# Java 线程池原理

> 分类: Java 并发 | 难度: ⭐⭐⭐⭐ | 频率: 高频

---

## 一、为什么需要线程池

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          为什么需要线程池                                         │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  直接创建线程的问题:                                                             │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │  new Thread(() -> doWork()).start();                                        │ │
│  │                                                                             │ │
│  │  问题:                                                                      │ │
│  │  • 创建/销毁线程开销大 (内核态切换、栈内存分配)                             │ │
│  │  • 线程数量不可控，可能导致资源耗尽                                         │ │
│  │  • 无法复用线程                                                             │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
│  线程池的优势:                                                                   │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │  • 线程复用: 减少创建/销毁开销                                              │ │
│  │  • 控制并发: 限制最大线程数                                                 │ │
│  │  • 统一管理: 提供线程监控、任务队列等能力                                   │ │
│  │  • 任务调度: 支持延迟执行、定时执行                                         │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 二、线程池核心参数

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                     ThreadPoolExecutor 7个核心参数                                │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  public ThreadPoolExecutor(                                                      │
│      int corePoolSize,           // 核心线程数                                   │
│      int maximumPoolSize,        // 最大线程数                                   │
│      long keepAliveTime,         // 非核心线程空闲存活时间                       │
│      TimeUnit unit,              // 时间单位                                     │
│      BlockingQueue<Runnable> workQueue,    // 任务队列                           │
│      ThreadFactory threadFactory,          // 线程工厂                           │
│      RejectedExecutionHandler handler      // 拒绝策略                           │
│  )                                                                               │
│                                                                                  │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  参数详解:                                                                       │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │  corePoolSize (核心线程数)                                                  │ │
│  │  • 线程池中始终存活的线程数                                                 │ │
│  │  • 即使空闲也不会被回收 (除非设置 allowCoreThreadTimeOut)                   │ │
│  │                                                                             │ │
│  │  maximumPoolSize (最大线程数)                                               │ │
│  │  • 线程池允许创建的最大线程数                                               │ │
│  │  • 当任务队列满时，会创建非核心线程，直到达到此值                           │ │
│  │                                                                             │ │
│  │  keepAliveTime (非核心线程空闲存活时间)                                     │ │
│  │  • 非核心线程空闲超过此时间会被回收                                         │ │
│  │                                                                             │ │
│  │  workQueue (任务队列)                                                       │ │
│  │  • 存放待执行任务                                                           │ │
│  │  • 常用: LinkedBlockingQueue, ArrayBlockingQueue, SynchronousQueue          │ │
│  │                                                                             │ │
│  │  threadFactory (线程工厂)                                                   │ │
│  │  • 创建线程的工厂，可自定义线程名称、优先级等                               │ │
│  │                                                                             │ │
│  │  handler (拒绝策略)                                                         │ │
│  │  • 任务队列满且达到最大线程数时的处理策略                                   │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 三、线程池执行流程

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          线程池执行流程                                           │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│                              提交任务 execute()                                   │
│                                    │                                             │
│                                    ↓                                             │
│                    ┌───────────────────────────────────┐                         │
│                    │ 当前线程数 < corePoolSize ?       │                         │
│                    └───────────────────────────────────┘                         │
│                          │ Yes                 │ No                              │
│                          ↓                     ↓                                 │
│              ┌─────────────────┐    ┌───────────────────────────┐                │
│              │ 创建核心线程    │    │ 任务入队 workQueue        │                │
│              │ 执行任务        │    └───────────────────────────┘                │
│              └─────────────────┘              │                                  │
│                                    ┌──────────┴─────────┐                        │
│                                    │ 入队成功?          │                        │
│                                    └──────────┬─────────┘                        │
│                              Yes │                     │ No (队列满)             │
│                                  ↓                     ↓                         │
│                        ┌─────────────────┐  ┌─────────────────────────┐          │
│                        │ 等待线程执行    │  │ 线程数 < maxPoolSize ?  │          │
│                        └─────────────────┘  └─────────────────────────┘          │
│                                                 │ Yes           │ No             │
│                                                 ↓               ↓                │
│                                    ┌─────────────────┐  ┌─────────────────┐      │
│                                    │ 创建非核心线程  │  │ 执行拒绝策略    │      │
│                                    │ 执行任务        │  └─────────────────┘      │
│                                    └─────────────────┘                           │
│                                                                                  │
│  记忆口诀: 核心线程 → 任务队列 → 最大线程 → 拒绝策略                             │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 四、代码示例

```java
/**
 * 创建线程池 (推荐方式)
 */
public class ThreadPoolExample {
    
    public static void main(String[] args) {
        // 推荐使用 ThreadPoolExecutor 手动创建
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            5,                      // 核心线程数
            10,                     // 最大线程数
            60, TimeUnit.SECONDS,   // 非核心线程空闲60秒回收
            new LinkedBlockingQueue<>(100),  // 有界队列，容量100
            new ThreadFactory() {
                private AtomicInteger count = new AtomicInteger(0);
                @Override
                public Thread newThread(Runnable r) {
                    Thread t = new Thread(r);
                    t.setName("my-thread-" + count.incrementAndGet());
                    return t;
                }
            },
            new ThreadPoolExecutor.CallerRunsPolicy()  // 拒绝策略
        );
        
        // 提交任务
        executor.execute(() -> {
            System.out.println("执行任务: " + Thread.currentThread().getName());
        });
        
        // 提交有返回值的任务
        Future<String> future = executor.submit(() -> {
            return "任务结果";
        });
        
        // 优雅关闭
        executor.shutdown();
    }
}

/**
 * 不推荐使用 Executors 工具类创建
 */
// Executors.newFixedThreadPool(10);      // 队列无界，可能OOM
// Executors.newCachedThreadPool();       // 最大线程数无限，可能OOM
// Executors.newSingleThreadExecutor();   // 队列无界，可能OOM
```

---

## 五、线程池状态

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          线程池状态                                               │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  RUNNING ──→ SHUTDOWN ──→ TIDYING ──→ TERMINATED                                 │
│     │                         ↑                                                  │
│     └────→ STOP ─────────────┘                                                   │
│                                                                                  │
│  • RUNNING    : 正常运行，接受新任务，处理队列任务                               │
│  • SHUTDOWN   : 不接受新任务，处理已提交的任务 (shutdown())                      │
│  • STOP       : 不接受新任务，不处理队列任务，中断正在执行的任务 (shutdownNow())  │
│  • TIDYING    : 所有任务已终止，workerCount = 0                                   │
│  • TERMINATED : terminated() 方法执行完成                                         │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 六、面试回答

### 30秒版本

> **线程池优势**：线程复用、控制并发、统一管理。
>
> **7个核心参数**：核心线程数、最大线程数、空闲存活时间、时间单位、任务队列、线程工厂、拒绝策略。
>
> **执行流程**：
> 1. 核心线程未满 → 创建核心线程执行
> 2. 核心线程满 → 任务入队
> 3. 队列满 → 创建非核心线程执行
> 4. 达到最大线程数 → 执行拒绝策略
>
> 推荐手动创建 `ThreadPoolExecutor`，不用 `Executors` 工具类。

### 1分钟版本

> **为什么需要线程池**：
> - 直接 new Thread() 开销大、无法复用、线程数不可控
> - 线程池实现线程复用、控制最大并发、提供监控能力
>
> **7个核心参数**：
> 1. corePoolSize：核心线程数，始终存活
> 2. maximumPoolSize：最大线程数
> 3. keepAliveTime：非核心线程空闲存活时间
> 4. unit：时间单位
> 5. workQueue：任务队列
> 6. threadFactory：线程工厂
> 7. handler：拒绝策略
>
> **执行流程**：
> 提交任务 → 核心线程未满则创建 → 已满则入队 → 队列满则创建非核心线程 → 达最大则执行拒绝策略
>
> **不用 Executors 的原因**：
> - newFixedThreadPool/newSingleThreadExecutor：队列无界，可能 OOM
> - newCachedThreadPool：最大线程数无限，可能 OOM
>
> **最佳实践**：
> - 手动创建 ThreadPoolExecutor
> - 使用有界队列
> - 自定义线程名称便于排查
> - 优雅关闭：shutdown() 等待任务完成
