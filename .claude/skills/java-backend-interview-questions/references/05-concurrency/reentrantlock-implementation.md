# ReentrantLock 的实现原理是什么？

> 分类: Java 并发 | 难度: ⭐⭐⭐⭐⭐ | 频率: 高频

---

## 一、核心概念

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                         ReentrantLock 核心                                        │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   定义: 基于 AQS (AbstractQueuedSynchronizer) 实现的可重入互斥锁                  │
│                                                                                  │
│   核心特性:                                                                       │
│   ┌────────────────────────────────────────────────────────────────────────────┐ │
│   │  1. 可重入: 同一线程可多次获取锁，state 累加                                │ │
│   │  2. 公平/非公平: 可选择是否按 FIFO 顺序获取锁                               │ │
│   │  3. 可中断: 支持 lockInterruptibly()                                        │ │
│   │  4. 可超时: 支持 tryLock(timeout)                                           │ │
│   │  5. 多条件: 支持多个 Condition 条件队列                                     │ │
│   └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 二、AQS 核心结构

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                    AbstractQueuedSynchronizer (AQS)                               │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   ┌────────────────────────────────────────────────────────────────────────────┐ │
│   │                          核心字段                                           │ │
│   │                                                                            │ │
│   │   volatile int state;           // 锁状态 (0=无锁, >0=锁定次数)            │ │
│   │   Thread exclusiveOwnerThread;  // 当前持有锁的线程                        │ │
│   │   Node head, tail;              // CLH 队列的头尾节点                      │ │
│   └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
│   ┌────────────────────────────────────────────────────────────────────────────┐ │
│   │                          CLH 等待队列                                       │ │
│   │                                                                            │ │
│   │      ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐         │ │
│   │      │   head   │───►│  Node 1  │───►│  Node 2  │───►│   tail   │         │ │
│   │      │ (哨兵)   │◄───│ Thread A │◄───│ Thread B │◄───│ Thread C │         │ │
│   │      └──────────┘    └──────────┘    └──────────┘    └──────────┘         │ │
│   │                                                                            │ │
│   │      双向链表，FIFO 顺序，等待获取锁的线程排队                              │ │
│   └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 三、Node 节点结构

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                              Node 节点                                            │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   static final class Node {                                                      │
│       volatile int waitStatus;      // 等待状态                                  │
│       volatile Node prev;           // 前驱节点                                  │
│       volatile Node next;           // 后继节点                                  │
│       volatile Thread thread;       // 等待的线程                                │
│       Node nextWaiter;              // 条件队列中的下一个节点                    │
│   }                                                                              │
│                                                                                  │
│   waitStatus 取值:                                                               │
│   ┌────────────────────────────────────────────────────────────────────────────┐ │
│   │  CANCELLED (1)  : 线程已取消，需要从队列移除                                │ │
│   │  SIGNAL (-1)    : 后继节点需要被唤醒                                        │ │
│   │  CONDITION (-2) : 线程在条件队列中等待                                      │ │
│   │  PROPAGATE (-3) : 共享模式下，释放应该传播                                  │ │
│   │  0              : 初始状态                                                  │ │
│   └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 四、非公平锁加锁流程

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                         非公平锁 lock() 流程                                      │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   lock()                                                                         │
│     │                                                                            │
│     ▼                                                                            │
│   ┌─────────────────────────────┐                                                │
│   │ CAS 尝试 state: 0 → 1      │ ──────── 成功 ──────────► 获取锁成功            │
│   └─────────────────────────────┘                          设置 owner = 当前线程 │
│     │ 失败                                                                       │
│     ▼                                                                            │
│   acquire(1)                                                                     │
│     │                                                                            │
│     ▼                                                                            │
│   ┌─────────────────────────────┐                                                │
│   │ tryAcquire(1)               │ ──────── 成功 ──────────► 获取锁成功           │
│   │ (再次尝试 + 重入检查)        │                                               │
│   └─────────────────────────────┘                                                │
│     │ 失败                                                                       │
│     ▼                                                                            │
│   ┌─────────────────────────────┐                                                │
│   │ addWaiter(Node.EXCLUSIVE)   │                                                │
│   │ 将当前线程封装为 Node       │                                                │
│   │ 加入 CLH 队列尾部           │                                                │
│   └─────────────────────────────┘                                                │
│     │                                                                            │
│     ▼                                                                            │
│   ┌─────────────────────────────┐                                                │
│   │ acquireQueued(node, 1)      │                                                │
│   │ 自旋获取锁或阻塞等待        │                                                │
│   └─────────────────────────────┘                                                │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 五、tryAcquire 核心逻辑

```java
// 非公平锁的 tryAcquire
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    
    // 情况1: 锁未被持有
    if (c == 0) {
        // 非公平: 直接 CAS 抢锁，不管队列中是否有等待线程
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;  // 获取成功
        }
    }
    // 情况2: 当前线程已持有锁 (可重入)
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;  // state 累加
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;  // 重入成功
    }
    
    return false;  // 获取失败
}
```

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          可重入机制                                               │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   线程 A 第一次获取锁:   state = 0 → 1,  owner = Thread A                        │
│   线程 A 第二次获取锁:   state = 1 → 2,  owner = Thread A (重入)                 │
│   线程 A 第三次获取锁:   state = 2 → 3,  owner = Thread A (重入)                 │
│                                                                                  │
│   线程 A 第一次释放锁:   state = 3 → 2,  锁仍被持有                              │
│   线程 A 第二次释放锁:   state = 2 → 1,  锁仍被持有                              │
│   线程 A 第三次释放锁:   state = 1 → 0,  owner = null, 锁完全释放                │
│                                                                                  │
│   结论: 获取几次就要释放几次，state 归零才真正释放锁                              │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 六、acquireQueued 自旋获取锁

```java
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {  // 自旋
            final Node p = node.predecessor();  // 获取前驱节点
            
            // 前驱是 head 且 tryAcquire 成功
            if (p == head && tryAcquire(arg)) {
                setHead(node);       // 当前节点成为新的 head
                p.next = null;       // help GC
                failed = false;
                return interrupted;  // 获取锁成功
            }
            
            // 判断是否应该阻塞
            if (shouldParkAfterFailedAcquire(p, node) &&
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                       acquireQueued 流程图                                        │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│                  ┌─────────────────────────────┐                                 │
│                  │      进入自旋循环           │                                 │
│                  └─────────────┬───────────────┘                                 │
│                                │                                                 │
│                                ▼                                                 │
│                  ┌─────────────────────────────┐                                 │
│              ┌───│   前驱是 head？             │                                 │
│              │   └─────────────────────────────┘                                 │
│              │ 是                                                                │
│              ▼                                                                   │
│   ┌─────────────────────────────┐                                                │
│   │     tryAcquire 成功？       │ ──── 是 ────► 获取锁成功，返回                 │
│   └─────────────────────────────┘                                                │
│              │ 否                                                                │
│              ▼                                                                   │
│   ┌─────────────────────────────┐                                                │
│   │  shouldParkAfterFailed      │                                                │
│   │  检查是否应该阻塞           │                                                │
│   └─────────────────────────────┘                                                │
│              │ 是                                                                │
│              ▼                                                                   │
│   ┌─────────────────────────────┐                                                │
│   │  LockSupport.park()         │                                                │
│   │  阻塞当前线程               │                                                │
│   └─────────────────────────────┘                                                │
│              │ 被唤醒                                                            │
│              └──────────────────────────────► 回到自旋开始                       │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 七、公平锁 vs 非公平锁

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                       公平锁 vs 非公平锁                                          │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   非公平锁 (默认):                                                               │
│   ┌────────────────────────────────────────────────────────────────────────────┐ │
│   │  lock() 时直接 CAS 抢锁                                                    │ │
│   │  tryAcquire() 时也直接抢，不管队列中是否有等待线程                          │ │
│   │                                                                            │ │
│   │  优点: 性能好，减少线程切换                                                 │ │
│   │  缺点: 可能导致线程饥饿                                                     │ │
│   └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
│   公平锁:                                                                        │
│   ┌────────────────────────────────────────────────────────────────────────────┐ │
│   │  lock() 时不直接抢，调用 acquire()                                         │ │
│   │  tryAcquire() 时先检查队列中是否有等待线程 (hasQueuedPredecessors)          │ │
│   │                                                                            │ │
│   │  优点: 保证 FIFO 顺序，不会饥饿                                             │ │
│   │  缺点: 性能差，频繁线程切换                                                 │ │
│   └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

```java
// 公平锁的 tryAcquire
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        // 公平锁: 先检查队列中是否有等待线程
        if (!hasQueuedPredecessors() &&  // 关键区别！
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        setState(nextc);
        return true;
    }
    return false;
}
```

---

## 八、unlock 释放锁流程

```java
public void unlock() {
    sync.release(1);
}

protected final boolean tryRelease(int releases) {
    int c = getState() - releases;  // state 减 1
    
    // 检查当前线程是否持有锁
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    
    boolean free = false;
    if (c == 0) {  // state 归零，完全释放
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
```

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                         unlock() 释放锁流程                                       │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   unlock()                                                                       │
│     │                                                                            │
│     ▼                                                                            │
│   release(1)                                                                     │
│     │                                                                            │
│     ▼                                                                            │
│   ┌─────────────────────────────┐                                                │
│   │ tryRelease(1)               │                                                │
│   │ state--                     │                                                │
│   └─────────────────────────────┘                                                │
│     │                                                                            │
│     ▼                                                                            │
│   ┌─────────────────────────────┐                                                │
│   │ state == 0 ?                │ ─── 否 ───► 返回 (仍持有锁，重入未完全释放)    │
│   └─────────────────────────────┘                                                │
│     │ 是                                                                         │
│     ▼                                                                            │
│   ┌─────────────────────────────┐                                                │
│   │ setExclusiveOwnerThread(null) │                                              │
│   │ 清除持有者                   │                                               │
│   └─────────────────────────────┘                                                │
│     │                                                                            │
│     ▼                                                                            │
│   ┌─────────────────────────────┐                                                │
│   │ unparkSuccessor(head)       │                                                │
│   │ 唤醒队列中下一个等待线程     │                                               │
│   └─────────────────────────────┘                                                │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 九、Condition 条件队列

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                         Condition 实现                                            │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   Condition condition = lock.newCondition();                                     │
│                                                                                  │
│   ┌────────────────────────────────────────────────────────────────────────────┐ │
│   │                                                                            │ │
│   │   同步队列 (CLH Queue):                                                    │ │
│   │   ┌──────┐    ┌──────┐    ┌──────┐                                        │ │
│   │   │ head │───►│Node A│───►│ tail │    等待获取锁的线程                    │ │
│   │   └──────┘    └──────┘    └──────┘                                        │ │
│   │                                                                            │ │
│   │   条件队列 (Condition Queue):                                              │ │
│   │   ┌──────────┐    ┌──────────┐                                            │ │
│   │   │firstWaiter│───►│lastWaiter│    调用 await() 等待的线程                 │ │
│   │   └──────────┘    └──────────┘                                            │ │
│   │                                                                            │ │
│   └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
│   await():  释放锁 → 加入条件队列 → 阻塞                                         │
│   signal(): 将节点从条件队列移到同步队列 → 等待获取锁                            │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 十、总结对比

| 特性 | ReentrantLock | synchronized |
|------|---------------|--------------|
| 实现层面 | JDK (AQS) | JVM (Monitor) |
| 状态管理 | volatile int state | Mark Word |
| 等待队列 | CLH 双向链表 | Monitor 的 _EntryList |
| 可重入 | state 计数 | 锁记录计数 |
| 公平性 | 可选 | 非公平 |
| 释放方式 | 手动 unlock | 自动 |

---

## 十一、记忆要点

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                              核心记忆点                                           │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   1. AQS 三要素: state + ownerThread + CLH 队列                                  │
│                                                                                  │
│   2. 可重入: state 累加/累减，归零才释放                                          │
│                                                                                  │
│   3. 非公平: 直接 CAS 抢锁                                                       │
│      公平:   先检查队列 hasQueuedPredecessors                                    │
│                                                                                  │
│   4. 获取锁失败: 加入 CLH 队列 → 自旋 + park 阻塞                                │
│                                                                                  │
│   5. 释放锁: tryRelease → unparkSuccessor 唤醒后继                               │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```
