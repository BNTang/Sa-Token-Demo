# Java 中有哪些垃圾回收算法？

## 垃圾回收算法概述

```
┌─────────────────────────────────────────────────────────────┐
│                    GC 算法概述                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   核心问题：                                                 │
│   1. 如何判断对象已死？                                     │
│   2. 如何回收死亡对象？                                     │
│                                                             │
│   判断算法：                                                 │
│   ├── 引用计数法                                            │
│   └── 可达性分析 (JVM 采用)                                 │
│                                                             │
│   回收算法：                                                 │
│   ├── 标记-清除 (Mark-Sweep)                                │
│   ├── 复制算法 (Copying)                                    │
│   ├── 标记-整理 (Mark-Compact)                              │
│   └── 分代收集 (Generational)                               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 一、引用计数法 (Reference Counting)

```
┌─────────────────────────────────────────────────────────────┐
│                    引用计数法                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   原理：每个对象维护一个引用计数器                           │
│         被引用时 +1，引用失效时 -1                           │
│         计数为 0 时回收                                      │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  Object A (count=2)                                 │  │
│   │      ↑       ↑                                      │  │
│   │      │       │                                      │  │
│   │   ref1    ref2                                      │  │
│   │                                                     │  │
│   │  ref1 = null → count=1                              │  │
│   │  ref2 = null → count=0 → 回收                       │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   优点：实时回收，延迟低                                     │
│                                                             │
│   缺点：无法处理循环引用                                     │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  ┌───────┐      ┌───────┐                          │  │
│   │  │   A   │ ───→ │   B   │                          │  │
│   │  │count=1│ ←─── │count=1│                          │  │
│   │  └───────┘      └───────┘                          │  │
│   │                                                     │  │
│   │  A 和 B 互相引用，计数永远不为 0                    │  │
│   │  即使外部没有引用，也无法回收 (内存泄漏)            │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   JVM 不使用此算法！Python、PHP 使用                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 二、可达性分析 (Reachability Analysis)

```
┌─────────────────────────────────────────────────────────────┐
│                    可达性分析                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   原理：从 GC Roots 出发，遍历对象图                        │
│         可达的对象存活，不可达的对象回收                     │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │          GC Roots                                   │  │
│   │     ┌───────┬───────┐                              │  │
│   │     │       │       │                              │  │
│   │     ▼       ▼       ▼                              │  │
│   │   ┌───┐   ┌───┐   ┌───┐                           │  │
│   │   │ A │   │ B │   │ C │  ← 存活                   │  │
│   │   └─┬─┘   └───┘   └─┬─┘                           │  │
│   │     │               │                              │  │
│   │     ▼               ▼                              │  │
│   │   ┌───┐           ┌───┐                           │  │
│   │   │ D │           │ E │  ← 存活                   │  │
│   │   └───┘           └───┘                           │  │
│   │                                                     │  │
│   │   ┌───┐   ┌───┐                                   │  │
│   │   │ F │ ─→│ G │  ← 不可达，回收                   │  │
│   │   └───┘   └───┘                                   │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   GC Roots 包括：                                           │
│   • 虚拟机栈中引用的对象                                    │
│   • 方法区中静态变量引用的对象                              │
│   • 方法区中常量引用的对象                                  │
│   • JNI (Native方法) 引用的对象                             │
│   • 同步锁持有的对象                                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 三、标记-清除 (Mark-Sweep)

```
┌─────────────────────────────────────────────────────────────┐
│                    标记-清除算法                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   阶段1：标记 (Mark)                                         │
│   从 GC Roots 遍历，标记所有存活对象                        │
│                                                             │
│   阶段2：清除 (Sweep)                                        │
│   遍历堆，回收未标记的对象                                   │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  标记前:                                            │  │
│   │  ┌───┬───┬───┬───┬───┬───┬───┬───┐               │  │
│   │  │ A │ B │ C │ D │ E │ F │ G │ H │               │  │
│   │  └───┴───┴───┴───┴───┴───┴───┴───┘               │  │
│   │                                                     │  │
│   │  标记后: (A, C, E, G 存活)                          │  │
│   │  ┌───┬───┬───┬───┬───┬───┬───┬───┐               │  │
│   │  │ A*│ B │ C*│ D │ E*│ F │ G*│ H │               │  │
│   │  └───┴───┴───┴───┴───┴───┴───┴───┘               │  │
│   │                                                     │  │
│   │  清除后:                                            │  │
│   │  ┌───┬───┬───┬───┬───┬───┬───┬───┐               │  │
│   │  │ A │   │ C │   │ E │   │ G │   │  ← 内存碎片   │  │
│   │  └───┴───┴───┴───┴───┴───┴───┴───┘               │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   优点：简单，不需要移动对象                                 │
│   缺点：                                                     │
│   • 产生内存碎片                                            │
│   • 效率不稳定 (对象多时慢)                                 │
│                                                             │
│   应用：CMS 老年代使用此算法                                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 四、复制算法 (Copying)

```
┌─────────────────────────────────────────────────────────────┐
│                    复制算法                                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   原理：将内存分为两块，每次只使用一块                       │
│         GC 时将存活对象复制到另一块，然后清空当前块         │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  GC 前:                                             │  │
│   │  ┌───────────────────────┐ ┌───────────────────────┐│  │
│   │  │ From 区 (使用中)      │ │ To 区 (空闲)          ││  │
│   │  │ A  B  C  D  E  F     │ │                       ││  │
│   │  └───────────────────────┘ └───────────────────────┘│  │
│   │                                                     │  │
│   │  GC 后: (A, C, E 存活，复制到 To 区)                │  │
│   │  ┌───────────────────────┐ ┌───────────────────────┐│  │
│   │  │ From 区 (清空)        │ │ To 区 (使用中)        ││  │
│   │  │                       │ │ A  C  E              ││  │
│   │  └───────────────────────┘ └───────────────────────┘│  │
│   │        (交换 From/To)                               │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   优点：                                                     │
│   • 无内存碎片                                              │
│   • 速度快 (只扫描存活对象)                                 │
│                                                             │
│   缺点：                                                     │
│   • 浪费一半内存空间                                        │
│                                                             │
│   优化：Eden + Survivor (8:1:1)                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  Eden (80%)         │ S0 (10%) │ S1 (10%)          │  │
│   │  新对象分配区       │ 存活区1  │ 存活区2           │  │
│   └─────────────────────────────────────────────────────┘  │
│   只浪费 10% 空间，适用于对象存活率低的场景                 │
│                                                             │
│   应用：年轻代使用此算法                                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 五、标记-整理 (Mark-Compact)

```
┌─────────────────────────────────────────────────────────────┐
│                    标记-整理算法                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   原理：标记存活对象，然后向一端移动，清理边界外内存         │
│                                                             │
│   阶段1：标记 (同标记-清除)                                  │
│   阶段2：整理 - 移动存活对象到内存一端                       │
│   阶段3：清除 - 清理边界外的内存                            │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  标记后:                                            │  │
│   │  ┌───┬───┬───┬───┬───┬───┬───┬───┐               │  │
│   │  │ A*│ B │ C*│ D │ E*│ F │ G*│ H │               │  │
│   │  └───┴───┴───┴───┴───┴───┴───┴───┘               │  │
│   │                                                     │  │
│   │  整理后: (存活对象移动到一端)                       │  │
│   │  ┌───┬───┬───┬───┬───────────────────┐            │  │
│   │  │ A │ C │ E │ G │      空闲空间      │            │  │
│   │  └───┴───┴───┴───┴───────────────────┘            │  │
│   │                  ↑                                  │  │
│   │              边界指针                               │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   优点：                                                     │
│   • 无内存碎片                                              │
│   • 不浪费内存空间                                          │
│                                                             │
│   缺点：                                                     │
│   • 移动对象开销大                                          │
│   • 需要更新引用                                            │
│                                                             │
│   应用：老年代使用此算法 (Serial Old, Parallel Old)         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 六、分代收集 (Generational Collection)

```
┌─────────────────────────────────────────────────────────────┐
│                    分代收集                                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   核心思想：根据对象存活时间分代，不同代使用不同算法         │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │                    堆内存划分                       │  │
│   │                                                     │  │
│   │  ┌───────────────────────────────────────────────┐ │  │
│   │  │               年轻代 (1/3)                     │ │  │
│   │  │  ┌────────────────────┬──────────┬──────────┐│ │  │
│   │  │  │    Eden (80%)      │ S0 (10%) │ S1 (10%) ││ │  │
│   │  │  │    新对象分配      │ 存活区   │ 存活区   ││ │  │
│   │  │  └────────────────────┴──────────┴──────────┘│ │  │
│   │  │  算法: 复制算法 (对象朝生夕死)                 │ │  │
│   │  └───────────────────────────────────────────────┘ │  │
│   │                                                     │  │
│   │  ┌───────────────────────────────────────────────┐ │  │
│   │  │               老年代 (2/3)                     │ │  │
│   │  │                                               │ │  │
│   │  │  存放长期存活的对象                            │ │  │
│   │  │  算法: 标记-整理 / 标记-清除                   │ │  │
│   │  └───────────────────────────────────────────────┘ │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   Minor GC: 回收年轻代 (频繁，快速)                         │
│   Major GC / Full GC: 回收老年代 (较慢)                     │
│                                                             │
│   对象晋升老年代条件：                                       │
│   • 年龄达到阈值 (默认15)                                   │
│   • Survivor 区装不下                                       │
│   • 大对象直接进入老年代                                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 算法对比

```
┌─────────────────────────────────────────────────────────────┐
│                    算法对比                                  │
├──────────────┬───────────┬────────────┬──────────────────────┤
│   算法        │  内存碎片  │  效率      │  适用场景            │
├──────────────┼───────────┼────────────┼──────────────────────┤
│   标记-清除  │   有       │  中        │ 老年代 (CMS)         │
│   复制算法   │   无       │  高        │ 年轻代               │
│   标记-整理  │   无       │  低        │ 老年代               │
├──────────────┴───────────┴────────────┴──────────────────────┤
│                                                             │
│   JVM 实际应用：                                             │
│   • 年轻代：复制算法 (存活率低，复制开销小)                 │
│   • 老年代：标记-整理 或 标记-清除                          │
│   • G1/ZGC：分 Region，混合使用多种算法                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 面试回答

### 30秒版本

> Java 垃圾回收算法：1）**标记-清除**：标记存活对象，清除未标记对象，会产生碎片；2）**复制算法**：分两块，复制存活对象到另一块，无碎片但浪费空间；3）**标记-整理**：标记后移动存活对象到一端，无碎片但移动开销大。JVM 采用**分代收集**：年轻代用复制算法，老年代用标记-整理/清除。

### 1分钟版本

> **判断存活**：JVM 使用可达性分析，从 GC Roots 遍历对象图，不可达的回收。
>
> **回收算法**：
>
> 1. **标记-清除**
>    - 标记存活对象，清除未标记对象
>    - 缺点：内存碎片
>    - 应用：CMS 老年代
>
> 2. **复制算法**
>    - 将存活对象复制到另一块内存
>    - 优点：无碎片、速度快
>    - 缺点：浪费空间
>    - 应用：年轻代 (Eden + S0 + S1 = 8:1:1)
>
> 3. **标记-整理**
>    - 标记后移动存活对象到一端
>    - 优点：无碎片、不浪费空间
>    - 缺点：移动开销大
>    - 应用：老年代 (Serial Old, Parallel Old)
>
> **分代收集**：年轻代对象朝生夕死用复制算法；老年代对象存活久用标记-整理。

---

*关联文档：[jvm-garbage-collectors.md](jvm-garbage-collectors.md) | [jvm-gc-tuning.md](jvm-gc-tuning.md) | [jvm-components.md](jvm-components.md)*
