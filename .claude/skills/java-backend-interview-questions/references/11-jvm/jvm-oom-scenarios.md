# JVM 有哪几种情况会产生 OOM（内存溢出）？

## OOM 类型概览

```
┌─────────────────────────────────────────────────────────────┐
│                    JVM OOM 类型                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. Java Heap Space                                        │
│      └── 堆内存不足                                         │
│                                                             │
│   2. Metaspace / PermGen                                    │
│      └── 元空间/永久代不足                                  │
│                                                             │
│   3. GC Overhead Limit Exceeded                             │
│      └── GC 时间过长                                        │
│                                                             │
│   4. Direct Buffer Memory                                   │
│      └── 直接内存不足                                       │
│                                                             │
│   5. Unable to Create New Native Thread                     │
│      └── 无法创建新线程                                     │
│                                                             │
│   6. Requested Array Size Exceeds VM Limit                  │
│      └── 数组大小超限                                       │
│                                                             │
│   7. Out of Swap Space                                      │
│      └── 交换空间不足                                       │
│                                                             │
│   8. Kill Process or Sacrifice Child                        │
│      └── 被 OOM Killer 杀死                                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 1. Java Heap Space

```
┌─────────────────────────────────────────────────────────────┐
│                    堆内存溢出                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   错误信息:                                                  │
│   java.lang.OutOfMemoryError: Java heap space               │
│                                                             │
│   原因:                                                      │
│   • 对象创建过多，堆内存不够                                │
│   • 内存泄漏，对象无法被回收                                │
│   • 大对象分配失败                                          │
│                                                             │
│   示例代码:                                                  │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  List<byte[]> list = new ArrayList<>();              │  │
│   │  while (true) {                                      │  │
│   │      list.add(new byte[10 * 1024 * 1024]); // 10MB  │  │
│   │  }                                                   │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   解决方案:                                                  │
│   • 增大堆内存: -Xmx4g                                      │
│   • 分析 dump 文件，找出大对象                              │
│   • 检查是否有内存泄漏                                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 2. Metaspace / PermGen

```
┌─────────────────────────────────────────────────────────────┐
│                    元空间溢出                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   错误信息:                                                  │
│   java.lang.OutOfMemoryError: Metaspace                     │
│   java.lang.OutOfMemoryError: PermGen space (JDK7及之前)    │
│                                                             │
│   原因:                                                      │
│   • 加载的类太多                                            │
│   • 动态生成大量类 (CGLib, ASM, JSP)                        │
│   • 反复重新部署应用 (热部署)                               │
│                                                             │
│   示例代码:                                                  │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  // 使用 CGLib 动态生成类                            │  │
│   │  while (true) {                                      │  │
│   │      Enhancer enhancer = new Enhancer();             │  │
│   │      enhancer.setSuperclass(Object.class);           │  │
│   │      enhancer.setCallback((MethodInterceptor)        │  │
│   │          (obj, method, args, proxy) -> null);        │  │
│   │      enhancer.create();                              │  │
│   │  }                                                   │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   解决方案:                                                  │
│   • 增大元空间: -XX:MaxMetaspaceSize=512m                   │
│   • 检查是否有类加载器泄漏                                  │
│   • 减少动态类生成                                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 3. GC Overhead Limit Exceeded

```
┌─────────────────────────────────────────────────────────────┐
│                    GC 开销过大                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   错误信息:                                                  │
│   java.lang.OutOfMemoryError: GC overhead limit exceeded    │
│                                                             │
│   触发条件:                                                  │
│   • GC 占用 98% 以上的时间                                  │
│   • 每次 GC 后回收内存不足 2%                               │
│                                                             │
│   原因:                                                      │
│   • 内存不足，疯狂 GC 但效果不佳                            │
│   • 大量临时对象                                            │
│   • 内存泄漏导致可用空间越来越少                            │
│                                                             │
│   解决方案:                                                  │
│   • 增大堆内存                                              │
│   • 优化代码，减少对象创建                                  │
│   • 分析内存泄漏                                            │
│   • 关闭该检查 (不推荐): -XX:-UseGCOverheadLimit            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 4. Direct Buffer Memory

```
┌─────────────────────────────────────────────────────────────┐
│                    直接内存溢出                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   错误信息:                                                  │
│   java.lang.OutOfMemoryError: Direct buffer memory          │
│                                                             │
│   原因:                                                      │
│   • NIO 的 ByteBuffer.allocateDirect() 分配过多             │
│   • Netty 使用的直接内存过多                                │
│   • 直接内存没有被及时释放                                  │
│                                                             │
│   示例代码:                                                  │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  List<ByteBuffer> list = new ArrayList<>();          │  │
│   │  while (true) {                                      │  │
│   │      // 分配 100MB 直接内存                          │  │
│   │      list.add(ByteBuffer.allocateDirect(            │  │
│   │          100 * 1024 * 1024));                        │  │
│   │  }                                                   │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   解决方案:                                                  │
│   • 增大直接内存: -XX:MaxDirectMemorySize=1g                │
│   • 检查 NIO ByteBuffer 是否被正确释放                      │
│   • 显式调用 System.gc() (不推荐)                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 5. Unable to Create New Native Thread

```
┌─────────────────────────────────────────────────────────────┐
│                    无法创建线程                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   错误信息:                                                  │
│   java.lang.OutOfMemoryError: unable to create new native   │
│   thread                                                    │
│                                                             │
│   原因:                                                      │
│   • 创建的线程太多                                          │
│   • 操作系统限制线程数量                                    │
│   • 每个线程的栈内存太大                                    │
│                                                             │
│   线程数计算:                                                │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  (系统最大进程数 - 系统当前进程数) * 线程/进程        │  │
│   │  或                                                  │  │
│   │  (MaxProcessMemory - JVMMemory - OS保留) / ThreadStack│  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   解决方案:                                                  │
│   • 减少线程数，使用线程池                                  │
│   • 减小线程栈大小: -Xss256k                                │
│   • 增加系统线程限制: ulimit -u                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 6. Requested Array Size Exceeds VM Limit

```
┌─────────────────────────────────────────────────────────────┐
│                    数组大小超限                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   错误信息:                                                  │
│   java.lang.OutOfMemoryError: Requested array size exceeds  │
│   VM limit                                                  │
│                                                             │
│   原因:                                                      │
│   • 尝试创建超大数组                                        │
│   • 数组长度超过 Integer.MAX_VALUE - 2                      │
│                                                             │
│   示例:                                                      │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  // 尝试创建超大数组                                 │  │
│   │  int[] arr = new int[Integer.MAX_VALUE];             │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   解决方案:                                                  │
│   • 检查数组大小计算逻辑                                    │
│   • 使用分片或分批处理                                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## OOM 排查步骤

```
┌─────────────────────────────────────────────────────────────┐
│                    OOM 排查流程                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. 开启 OOM 时自动 dump                                   │
│      -XX:+HeapDumpOnOutOfMemoryError                        │
│      -XX:HeapDumpPath=/path/to/dump                         │
│                                                             │
│   2. 分析 dump 文件                                         │
│      使用 MAT (Memory Analyzer Tool)                        │
│      jhat、VisualVM 等工具                                  │
│                                                             │
│   3. 常用命令                                                │
│      jmap -heap <pid>           # 查看堆内存使用            │
│      jmap -histo <pid>          # 对象统计                  │
│      jstat -gcutil <pid> 1000   # GC 统计                   │
│                                                             │
│   4. 分析重点                                                │
│      • 找出占用内存最大的对象                               │
│      • 查看 GC Root 引用链                                  │
│      • 检查是否有内存泄漏                                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 面试回答

### 30秒版本

> JVM OOM 常见类型：1）**Java Heap Space**：堆内存不足，对象太多或内存泄漏；2）**Metaspace**：元空间不足，加载类太多；3）**GC Overhead Limit**：GC 占用 98% 时间但回收不足 2%；4）**Direct Buffer Memory**：NIO 直接内存不足；5）**Unable to Create Native Thread**：线程太多。排查时开启 `-XX:+HeapDumpOnOutOfMemoryError`，用 MAT 分析 dump。

### 1分钟版本

> **常见 OOM 类型**：
>
> 1. **Java Heap Space**
>    - 堆内存不足
>    - 解决：增大 `-Xmx`，检查内存泄漏
>
> 2. **Metaspace**
>    - 元空间不足，类太多
>    - 常见于动态代理、热部署
>    - 解决：增大 `-XX:MaxMetaspaceSize`
>
> 3. **GC Overhead Limit Exceeded**
>    - GC 占 98% 时间，回收不足 2%
>    - 解决：增大堆或优化代码
>
> 4. **Direct Buffer Memory**
>    - NIO 直接内存不足
>    - 解决：增大 `-XX:MaxDirectMemorySize`
>
> 5. **Unable to Create Native Thread**
>    - 线程太多
>    - 解决：使用线程池，减小栈大小 `-Xss`
>
> **排查步骤**：
> - 开启 dump：`-XX:+HeapDumpOnOutOfMemoryError`
> - 用 MAT 分析大对象和 GC Root 引用链

---

*关联文档：[jvm-memory-analysis.md](jvm-memory-analysis.md) | [jvm-gc-tuning.md](jvm-gc-tuning.md)*
