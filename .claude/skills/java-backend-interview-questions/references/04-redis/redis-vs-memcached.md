# Redis 与 Memcached 的区别

> 分类: 缓存 | 难度: ⭐⭐⭐ | 频率: 高频

---

## 一、核心区别

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                        Redis vs Memcached                                         │
├─────────────────┬────────────────────────────┬───────────────────────────────────┤
│                 │        Redis               │         Memcached                 │
├─────────────────┼────────────────────────────┼───────────────────────────────────┤
│   数据结构      │  丰富(String/List/Hash等)  │  只有 String                      │
│   持久化        │  ✅ RDB + AOF              │  ❌ 不支持                        │
│   内存管理      │  预分配 + jemalloc         │  Slab Allocation                  │
│   线程模型      │  单线程(6.0+多线程IO)      │  多线程                           │
│   集群          │  ✅ 原生支持               │  ❌ 需客户端分片                  │
│   事务          │  ✅ 支持(MULTI/EXEC)       │  ❌ 不支持                        │
│   Lua脚本       │  ✅ 支持                   │  ❌ 不支持                        │
│   发布订阅      │  ✅ 支持                   │  ❌ 不支持                        │
│   数据淘汰      │  8种策略                   │  LRU                              │
│   最大值大小    │  512MB                     │  1MB                              │
└─────────────────┴────────────────────────────┴───────────────────────────────────┘
```

---

## 二、数据结构对比

### 2.1 Redis 丰富的数据结构

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                        Redis 数据结构                                             │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  基础类型:                                                                       │
│  ┌─────────────┬───────────────────────────────────────────────────────────────┐│
│  │  String     │  字符串、数字、二进制数据                                      ││
│  │  List       │  双向链表，支持阻塞操作                                        ││
│  │  Hash       │  键值对集合，类似 HashMap                                      ││
│  │  Set        │  无序集合，支持交并差集                                        ││
│  │  ZSet       │  有序集合，按分数排序                                          ││
│  └─────────────┴───────────────────────────────────────────────────────────────┘│
│                                                                                  │
│  高级类型:                                                                       │
│  ┌─────────────┬───────────────────────────────────────────────────────────────┐│
│  │  Bitmap     │  位图，布尔运算                                                ││
│  │  HyperLogLog│  基数统计，误差0.81%                                           ││
│  │  Geo        │  地理位置                                                      ││
│  │  Stream     │  消息队列                                                      ││
│  └─────────────┴───────────────────────────────────────────────────────────────┘│
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 Memcached 只有 String

```
Memcached 只支持简单的键值对:
┌──────────────────────────────────────────────────────────────────────────────────┐
│  set user:1001 0 3600 11                                                         │
│  Hello World                                                                      │
│                                                                                  │
│  get user:1001                                                                   │
│  VALUE user:1001 0 11                                                            │
│  Hello World                                                                      │
│  END                                                                             │
└──────────────────────────────────────────────────────────────────────────────────┘

如果需要存储复杂对象，必须序列化为字符串
```

---

## 三、持久化对比

### 3.1 Redis 持久化

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                        Redis 持久化方式                                           │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  RDB (快照):                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────┐│
│  │  • 定时将内存数据保存到磁盘                                                  ││
│  │  • 恢复速度快                                                                ││
│  │  • 可能丢失最后一次快照后的数据                                              ││
│  │  • save 900 1  # 900秒内有1次修改则保存                                      ││
│  └─────────────────────────────────────────────────────────────────────────────┘│
│                                                                                  │
│  AOF (追加日志):                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────────────┐│
│  │  • 记录每个写操作命令                                                        ││
│  │  • 数据安全性更高                                                            ││
│  │  • 文件大，恢复慢                                                            ││
│  │  • appendfsync everysec  # 每秒同步                                          ││
│  └─────────────────────────────────────────────────────────────────────────────┘│
│                                                                                  │
│  混合持久化 (Redis 4.0+):                                                        │
│  ┌─────────────────────────────────────────────────────────────────────────────┐│
│  │  • 结合 RDB 和 AOF 的优点                                                    ││
│  │  • AOF 重写时使用 RDB 格式 + 增量 AOF                                        ││
│  └─────────────────────────────────────────────────────────────────────────────┘│
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

### 3.2 Memcached 无持久化

```
Memcached 是纯内存缓存:
• 服务重启后数据全部丢失
• 适合缓存可重建的数据
• 如需持久化，可考虑 memcachedb 等变体
```

---

## 四、内存管理对比

### 4.1 Memcached Slab 分配

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                        Memcached Slab Allocation                                  │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  预先将内存分割成不同大小的 Slab Class:                                          │
│                                                                                  │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │  Slab Class 1: 96 bytes   ████████████████████████                         │ │
│  │  Slab Class 2: 120 bytes  ██████████████████████                           │ │
│  │  Slab Class 3: 152 bytes  ████████████████████                             │ │
│  │  Slab Class 4: 192 bytes  ██████████████████                               │ │
│  │  ...                                                                       │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
│  优点: 避免内存碎片                                                              │
│  缺点: 可能造成内存浪费 (100字节数据用152字节Slab)                               │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

### 4.2 Redis 内存管理

```
Redis 使用 jemalloc (或其他分配器):
• 更细粒度的内存分配
• 内存碎片相对较少
• 支持内存碎片整理 (Redis 4.0+)
```

---

## 五、线程模型对比

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                        线程模型对比                                               │
├─────────────────┬────────────────────────────┬───────────────────────────────────┤
│                 │        Redis               │         Memcached                 │
├─────────────────┼────────────────────────────┼───────────────────────────────────┤
│  模型           │  单线程(命令处理)          │  多线程                           │
│  IO             │  6.0+多线程IO              │  多线程IO                         │
│  锁开销         │  无锁竞争                  │  需要加锁                         │
│  CPU利用        │  单核(可启动多实例)        │  多核                             │
│  一致性         │  天然保证                  │  需要CAS                          │
└─────────────────┴────────────────────────────┴───────────────────────────────────┘

Redis 单线程为什么这么快?
• 纯内存操作
• 非阻塞 I/O 多路复用 (epoll)
• 避免多线程上下文切换和锁竞争
• 数据结构优化
```

---

## 六、集群对比

### 6.1 Redis Cluster

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                        Redis Cluster                                              │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐                           │
│  │  Master 1    │  │  Master 2    │  │  Master 3    │                           │
│  │  Slot 0-5460 │  │ Slot 5461-10922│ │Slot 10923-16383│                        │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘                           │
│         │                 │                 │                                    │
│         ↓                 ↓                 ↓                                    │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐                           │
│  │  Slave 1     │  │  Slave 2     │  │  Slave 3     │                           │
│  └──────────────┘  └──────────────┘  └──────────────┘                           │
│                                                                                  │
│  特点:                                                                           │
│  • 16384 个哈希槽                                                                │
│  • 自动故障转移                                                                  │
│  • 无需代理，客户端直连                                                          │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

### 6.2 Memcached 客户端分片

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                        Memcached 客户端分片                                       │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│      客户端 (一致性Hash)                                                         │
│           │                                                                      │
│     ┌─────┼─────┐                                                                │
│     ↓     ↓     ↓                                                                │
│  ┌──────┐ ┌──────┐ ┌──────┐                                                      │
│  │ MC 1 │ │ MC 2 │ │ MC 3 │    各节点相互独立                                    │
│  └──────┘ └──────┘ └──────┘                                                      │
│                                                                                  │
│  特点:                                                                           │
│  • 需要客户端实现分片逻辑                                                        │
│  • 无自动故障转移                                                                │
│  • 扩缩容需要手动迁移数据                                                        │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 七、使用场景对比

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                        使用场景对比                                               │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  选择 Redis:                                                                     │
│  ┌─────────────────────────────────────────────────────────────────────────────┐│
│  │  ✓ 需要复杂数据结构 (List/Hash/Set/ZSet)                                    ││
│  │  ✓ 需要持久化                                                                ││
│  │  ✓ 需要发布订阅                                                              ││
│  │  ✓ 需要 Lua 脚本原子操作                                                     ││
│  │  ✓ 需要分布式锁                                                              ││
│  │  ✓ 需要原生集群支持                                                          ││
│  │  ✓ 需要消息队列 (Stream)                                                     ││
│  └─────────────────────────────────────────────────────────────────────────────┘│
│                                                                                  │
│  选择 Memcached:                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────────────┐│
│  │  ✓ 纯缓存场景，不需要持久化                                                  ││
│  │  ✓ 只需要简单的 key-value                                                    ││
│  │  ✓ 需要多线程利用多核 CPU                                                    ││
│  │  ✓ 缓存大量小对象                                                            ││
│  │  ✓ 已有 Memcached 生态系统                                                   ││
│  └─────────────────────────────────────────────────────────────────────────────┘│
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 八、面试回答

### 30秒版本

> Redis 和 Memcached 主要区别：
> 1. **数据结构**：Redis 支持丰富类型（String/List/Hash/Set/ZSet），Memcached 只有 String
> 2. **持久化**：Redis 支持 RDB+AOF，Memcached 不支持
> 3. **线程模型**：Redis 单线程，Memcached 多线程
> 4. **集群**：Redis 原生支持集群，Memcached 需客户端分片
>
> 现在 Redis 使用更广泛，功能更强大。

### 1分钟版本

> **数据结构：**
> Redis 支持 String、List、Hash、Set、ZSet 等多种数据结构，可以直接在服务端完成复杂操作；Memcached 只支持简单的 key-value 字符串。
>
> **持久化：**
> Redis 支持 RDB 快照和 AOF 日志两种持久化方式，可以保证数据安全；Memcached 是纯内存存储，重启后数据丢失。
>
> **线程模型：**
> Redis 命令处理是单线程（6.0 后 IO 多线程），避免了锁竞争，保证原子性；Memcached 是多线程，能更好利用多核 CPU。
>
> **集群支持：**
> Redis 原生支持 Cluster 集群，自动分片和故障转移；Memcached 需要客户端实现一致性 Hash 分片。
>
> **选型建议：**
> 需要复杂数据结构、持久化、分布式锁、消息队列等场景选 Redis；纯缓存场景、只需简单 KV 可以选 Memcached。

---

## 九、代码示例

### 9.1 Redis Java 客户端

```java
// Jedis 示例
Jedis jedis = new Jedis("localhost", 6379);

// 丰富的数据结构操作
jedis.set("key", "value");                    // String
jedis.lpush("list", "a", "b", "c");           // List
jedis.hset("hash", "field", "value");         // Hash
jedis.sadd("set", "a", "b", "c");             // Set
jedis.zadd("zset", 1.0, "a");                 // ZSet

// 事务
Transaction tx = jedis.multi();
tx.set("k1", "v1");
tx.incr("counter");
tx.exec();

// Lua 脚本
String script = "return redis.call('set',KEYS[1],ARGV[1])";
jedis.eval(script, 1, "key", "value");
```

### 9.2 Memcached Java 客户端

```java
// Spymemcached 示例
MemcachedClient client = new MemcachedClient(
    new InetSocketAddress("localhost", 11211));

// 只有简单的 key-value 操作
client.set("key", 3600, "value");
String value = (String) client.get("key");

// CAS 操作保证原子性
CASValue<Object> casValue = client.gets("key");
client.cas("key", casValue.getCas(), "newValue");

// 不支持复杂数据结构，需要序列化
User user = new User("张三", 28);
client.set("user:1", 3600, JSON.toJSONString(user));
```
