# Redis 内存淘汰策略

> 分类: Redis | 难度: ⭐⭐⭐ | 频率: 高频

---

## 一、内存淘汰触发时机

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          内存淘汰触发时机                                         │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  1. 设置最大内存限制                                                             │
│     maxmemory 100mb                                                              │
│                                                                                  │
│  2. 内存使用达到 maxmemory 时触发                                                │
│                                                                                  │
│  3. 每次执行命令前检查内存                                                       │
│     if (used_memory > maxmemory) {                                               │
│         执行内存淘汰策略                                                         │
│     }                                                                            │
│                                                                                  │
│  注意:                                                                           │
│  • 未设置 maxmemory 时，64位系统默认不限制                                       │
│  • 过期删除 ≠ 内存淘汰（过期删除是删除过期key，内存淘汰是空间不够时删除）         │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 二、八种内存淘汰策略

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          八种内存淘汰策略                                         │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  1. 不淘汰策略                                                                   │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │  noeviction (默认)                                                          │ │
│  │  不淘汰，内存满时写入操作返回错误                                           │ │
│  │  读操作正常                                                                 │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
│  2. 设置了过期时间的 key 中淘汰 (volatile-*)                                     │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │  volatile-lru      最近最少使用 (LRU)                                       │ │
│  │  volatile-lfu      最不经常使用 (LFU) - Redis 4.0+                          │ │
│  │  volatile-ttl      即将过期的优先淘汰                                       │ │
│  │  volatile-random   随机淘汰                                                 │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
│  3. 所有 key 中淘汰 (allkeys-*)                                                  │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │  allkeys-lru       最近最少使用 (LRU)                                       │ │
│  │  allkeys-lfu       最不经常使用 (LFU) - Redis 4.0+                          │ │
│  │  allkeys-random    随机淘汰                                                 │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘

策略选择:
┌────────────────────────────────────────────────────────────────────────────────┐
│  业务场景                               推荐策略                               │
├────────────────────────────────────────────────────────────────────────────────┤
│  缓存场景，有热点数据                    allkeys-lru 或 allkeys-lfu            │
│  所有 key 访问频率相近                   allkeys-random                        │
│  业务有明确的冷热数据区分                volatile-lru                          │
│  有些 key 不允许删除                     volatile-* 系列                       │
└────────────────────────────────────────────────────────────────────────────────┘
```

---

## 三、LRU vs LFU

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          LRU vs LFU                                               │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  LRU (Least Recently Used) - 最近最少使用                                        │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │  淘汰最长时间未被访问的 key                                                 │ │
│  │                                                                             │ │
│  │  问题: 偶发性批量访问会污染缓存                                             │ │
│  │  例: 大促时批量查询冷数据，热数据被淘汰                                     │ │
│  │                                                                             │ │
│  │  Redis 实现: 近似 LRU                                                       │ │
│  │  • 随机采样 N 个 key (默认5个)                                              │ │
│  │  • 淘汰其中最久未访问的                                                     │ │
│  │  • 不是精确 LRU，但节省内存                                                 │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
│  LFU (Least Frequently Used) - 最不经常使用 (Redis 4.0+)                         │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │  淘汰访问频率最低的 key                                                     │ │
│  │                                                                             │ │
│  │  优势: 抵抗偶发批量访问                                                     │ │
│  │  • 热点数据频率高，不会被淘汰                                               │ │
│  │  • 偶发访问的冷数据频率低，优先淘汰                                         │ │
│  │                                                                             │ │
│  │  实现: 计数器 + 时间衰减                                                    │ │
│  │  • 每次访问增加计数                                                         │ │
│  │  • 随时间衰减，防止历史热点永不淘汰                                         │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
│  推荐: 大多数场景 LFU 效果更好                                                   │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 四、配置方法

```bash
# redis.conf 配置

# 设置最大内存 (必须设置，否则不会触发淘汰)
maxmemory 100mb

# 设置淘汰策略
maxmemory-policy allkeys-lru

# LRU/LFU 采样数量 (越大越精确，CPU 消耗越大)
maxmemory-samples 5

# 动态修改 (运行时)
CONFIG SET maxmemory 200mb
CONFIG SET maxmemory-policy allkeys-lfu
```

---

## 五、面试回答

### 30秒版本

> Redis 有 **8 种内存淘汰策略**：
>
> - **noeviction**（默认）：不淘汰，内存满时写入报错
> - **volatile-\*** 系列：从设置了过期时间的 key 中淘汰
> - **allkeys-\*** 系列：从所有 key 中淘汰
>
> LRU：淘汰最久未访问的；LFU：淘汰访问频率最低的。
>
> **推荐**：缓存场景用 `allkeys-lru` 或 `allkeys-lfu`。

### 1分钟版本

> **触发时机**：
> 设置了 maxmemory，内存使用达到上限时触发。
>
> **8种策略**：
>
> 1. **noeviction**（默认）：不淘汰，写入返回错误
>
> 2. **volatile-\*** 系列（只淘汰设置了过期时间的 key）：
>    - volatile-lru：最近最少使用
>    - volatile-lfu：最不经常使用
>    - volatile-ttl：即将过期的优先
>    - volatile-random：随机
>
> 3. **allkeys-\*** 系列（淘汰所有 key）：
>    - allkeys-lru：最近最少使用
>    - allkeys-lfu：最不经常使用
>    - allkeys-random：随机
>
> **LRU vs LFU**：
> - LRU：淘汰最长时间未访问的，但偶发批量访问会污染缓存
> - LFU：淘汰访问频率最低的，抵抗偶发批量访问，推荐使用
>
> **策略选择**：
> - 缓存场景：allkeys-lru 或 allkeys-lfu
> - 有些 key 不能删：volatile-* 系列
> - 访问频率相近：allkeys-random
