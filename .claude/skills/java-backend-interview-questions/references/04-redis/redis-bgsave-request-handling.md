# Redis 在生成 RDB 文件时如何处理请求？

## BGSAVE 工作原理

```
┌─────────────────────────────────────────────────────────────┐
│                    BGSAVE 工作原理                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   BGSAVE 执行流程:                                           │
│                                                             │
│   ┌─────────────────┐        fork()        ┌─────────────────┐
│   │   Redis 主进程   │ ──────────────────→ │   Redis 子进程   │
│   │  (继续处理请求)  │                      │  (生成 RDB 文件) │
│   └────────┬────────┘                      └────────┬────────┘
│            │                                        │
│            │                                        │
│   ┌────────▼────────┐                      ┌────────▼────────┐
│   │  处理读写请求   │                      │   遍历内存数据   │
│   │  正常响应客户端 │                      │   写入 RDB 文件  │
│   └─────────────────┘                      └─────────────────┘
│                                                             │
│   关键: fork() 后父子进程共享内存页 (Copy-On-Write)         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## Copy-On-Write 机制

```
┌─────────────────────────────────────────────────────────────┐
│                    Copy-On-Write (写时复制)                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   fork() 时刻:                                               │
│   ┌───────────────────────────────────────────────────────┐ │
│   │   物理内存                                             │ │
│   │   ┌─────┬─────┬─────┬─────┬─────┐                     │ │
│   │   │Page1│Page2│Page3│Page4│Page5│                     │ │
│   │   └──┬──┴──┬──┴──┬──┴──┬──┴──┬──┘                     │ │
│   │      │     │     │     │     │                         │ │
│   │      └──────────┬──────────────┘                       │ │
│   │                 │ 共享                                 │ │
│   │      ┌──────────┴──────────┐                          │ │
│   │      ▼                     ▼                          │ │
│   │   ┌──────┐              ┌──────┐                      │ │
│   │   │ 父进程│              │ 子进程│                      │ │
│   │   │页表指向│              │页表指向│                      │ │
│   │   │相同物理页│            │相同物理页│                    │ │
│   │   └──────┘              └──────┘                      │ │
│   └───────────────────────────────────────────────────────┘ │
│                                                             │
│   父进程写入时:                                              │
│   ┌───────────────────────────────────────────────────────┐ │
│   │   父进程修改 Page2:                                    │ │
│   │   1. OS 复制 Page2 到新物理页 Page2'                   │ │
│   │   2. 父进程页表指向 Page2' (新页)                      │ │
│   │   3. 子进程页表仍指向 Page2 (原页)                     │ │
│   │                                                       │ │
│   │   ┌─────┬─────┬─────┬─────┬─────┬─────┐              │ │
│   │   │Page1│Page2│Page3│Page4│Page5│Page2'│              │ │
│   │   └──┬──┴──┬──┴──┬──┴──┬──┴──┬──┴──┬───┘              │ │
│   │      │     │     │     │     │     │                   │ │
│   │   父进程   │  │ │ │ │ │ │ │ │ │ ←────┘                   │ │
│   │      │     │     │     │     │                         │ │
│   │   子进程──→│     │     │     │                         │ │
│   │      (子进程看到的是 fork() 时刻的快照)                │ │
│   └───────────────────────────────────────────────────────┘ │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## BGSAVE 期间请求处理

```
┌─────────────────────────────────────────────────────────────┐
│                    BGSAVE 期间的请求处理                     │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   读请求:                                                    │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  • 正常处理，不受影响                                │  │
│   │  • 读取的是父进程的最新数据                          │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   写请求:                                                    │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  • 正常处理，不阻塞                                  │  │
│   │  • 触发 COW，复制被修改的内存页                      │  │
│   │  • 子进程仍使用原页 (快照数据)                       │  │
│   │  • RDB 文件是 fork 时刻的数据快照                    │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   注意事项:                                                  │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  1. fork() 本身可能短暂阻塞                          │  │
│   │     - 内存越大，fork 越慢                            │  │
│   │     - 通常毫秒级，极端情况秒级                       │  │
│   │                                                     │  │
│   │  2. 内存可能翻倍                                     │  │
│   │     - 极端情况：BGSAVE 期间所有页都被修改            │  │
│   │     - 需要预留足够内存                               │  │
│   │                                                     │  │
│   │  3. RDB 不包含 BGSAVE 期间的新数据                   │  │
│   │     - 数据可能有几秒延迟                             │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## SAVE vs BGSAVE

```
┌─────────────────────────────────────────────────────────────┐
│                    SAVE vs BGSAVE                           │
├──────────────────┬──────────────────────────────────────────┤
│   命令           │   说明                                   │
├──────────────────┼──────────────────────────────────────────┤
│   SAVE           │ 同步执行，阻塞所有请求                   │
│                  │ 直到 RDB 生成完成才响应                  │
│                  │ 生产环境禁用                             │
├──────────────────┼──────────────────────────────────────────┤
│   BGSAVE         │ 异步执行，fork 子进程处理                │
│                  │ 主进程继续响应请求                       │
│                  │ 生产环境推荐                             │
├──────────────────┴──────────────────────────────────────────┤
│                                                             │
│   自动触发 BGSAVE:                                          │
│   save 900 1      # 900 秒内有 1 次修改                     │
│   save 300 10     # 300 秒内有 10 次修改                    │
│   save 60 10000   # 60 秒内有 10000 次修改                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## AOF 重写时的处理

```
┌─────────────────────────────────────────────────────────────┐
│                    AOF 重写 (BGREWRITEAOF)                   │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   与 BGSAVE 类似，也使用 fork + COW:                        │
│                                                             │
│   ┌─────────────────┐        fork()        ┌─────────────────┐
│   │   Redis 主进程   │ ──────────────────→ │   Redis 子进程   │
│   │  (继续处理请求)  │                      │  (重写 AOF 文件) │
│   └────────┬────────┘                      └─────────────────┘
│            │                                                 │
│            ▼                                                 │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  重写期间的新命令同时写入:                           │  │
│   │  1. 现有 AOF 文件 (保证安全)                         │  │
│   │  2. AOF 重写缓冲区                                   │  │
│   │                                                     │  │
│   │  子进程完成后:                                       │  │
│   │  将重写缓冲区内容追加到新 AOF 文件                   │  │
│   │  原子替换旧 AOF 文件                                 │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 优化建议

```
┌─────────────────────────────────────────────────────────────┐
│                    优化建议                                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. 预留足够内存                                            │
│      └── 至少预留 50% 内存给 COW                            │
│                                                             │
│   2. 关闭 THP (Transparent Huge Pages)                      │
│      echo never > /sys/kernel/mm/transparent_hugepage/enabled│
│      └── 避免 fork 时复制大页面导致延迟                     │
│                                                             │
│   3. 在从节点执行持久化                                      │
│      └── 主节点专注处理请求                                 │
│                                                             │
│   4. 合理配置持久化策略                                      │
│      └── 避免过于频繁的 BGSAVE                              │
│                                                             │
│   5. 监控 fork 耗时                                          │
│      INFO stats → latest_fork_usec                          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 面试回答

### 30秒版本

> Redis BGSAVE 生成 RDB 时使用 **fork() + Copy-On-Write**。fork 创建子进程，父子进程共享内存页。主进程继续处理读写请求，写操作触发 COW 复制被修改的页。子进程看到的是 fork 时刻的数据快照，写入 RDB 文件。整个过程不阻塞客户端（fork 本身可能毫秒级阻塞），但极端情况内存可能翻倍。

### 1分钟版本

> **BGSAVE 执行过程**：
> 1. 主进程调用 fork() 创建子进程
> 2. fork 后父子进程共享内存页（物理内存相同）
> 3. 主进程继续处理客户端请求
> 4. 子进程遍历内存，将数据写入 RDB 文件
>
> **Copy-On-Write 机制**：
> - 读请求：正常处理，无影响
> - 写请求：触发 COW，操作系统复制被修改的内存页
>   - 主进程修改新页
>   - 子进程仍用原页（快照数据）
>
> **注意事项**：
> - fork() 本身可能阻塞（毫秒级，内存越大越慢）
> - 极端情况内存可能翻倍（需预留 50%）
> - RDB 是 fork 时刻的快照，不含之后的数据
>
> **优化建议**：
> - 预留足够内存
> - 在从节点做持久化
> - 关闭 THP

---

*关联文档：[redis-persistence.md](redis-persistence.md) | [redis-replication.md](redis-replication.md)*
