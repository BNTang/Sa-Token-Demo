# 什么是 Java 的多态特性？

## 多态概念

```
┌─────────────────────────────────────────────────────────────┐
│                    多态 (Polymorphism)                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   定义:                                                      │
│   同一个行为具有多个不同表现形式                            │
│   父类引用指向子类对象，调用方法时执行子类的实现            │
│                                                             │
│   本质:                                                      │
│   运行时确定调用哪个方法（动态绑定）                        │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  Animal animal = new Dog();  // 父类引用指向子类对象│  │
│   │  animal.speak();  // 运行时调用 Dog 的 speak()      │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 多态的三个条件

```
┌─────────────────────────────────────────────────────────────┐
│                    多态三个必要条件                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. 继承关系 (或实现接口)                                   │
│      └── class Dog extends Animal                           │
│                                                             │
│   2. 方法重写 (Override)                                     │
│      └── 子类重写父类方法                                   │
│                                                             │
│   3. 父类引用指向子类对象                                    │
│      └── Animal animal = new Dog();                         │
│                                                             │
│   缺一不可！                                                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 代码示例

```java
// 1. 父类
class Animal {
    public void speak() {
        System.out.println("Animal speaks");
    }
    
    public void eat() {
        System.out.println("Animal eats");
    }
}

// 2. 子类重写方法
class Dog extends Animal {
    @Override
    public void speak() {
        System.out.println("Dog barks: Woof!");
    }
    
    // Dog 特有方法
    public void fetch() {
        System.out.println("Dog fetches ball");
    }
}

class Cat extends Animal {
    @Override
    public void speak() {
        System.out.println("Cat meows: Meow!");
    }
}

// 3. 多态使用
public class PolymorphismDemo {
    public static void main(String[] args) {
        // 父类引用指向子类对象
        Animal animal1 = new Dog();
        Animal animal2 = new Cat();
        
        // 运行时确定调用哪个方法
        animal1.speak();  // 输出: Dog barks: Woof!
        animal2.speak();  // 输出: Cat meows: Meow!
        
        // 多态的实际应用
        makeSpeak(new Dog());  // Dog barks: Woof!
        makeSpeak(new Cat());  // Cat meows: Meow!
    }
    
    // 方法参数使用父类类型，可以接收任意子类
    public static void makeSpeak(Animal animal) {
        animal.speak();  // 多态调用
    }
}
```

## 多态的类型

```
┌─────────────────────────────────────────────────────────────┐
│                    多态的类型                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. 运行时多态 (Runtime Polymorphism)                      │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  • 方法重写实现                                      │  │
│   │  • 动态绑定，运行时确定                              │  │
│   │  • 最常说的多态                                      │  │
│   │                                                     │  │
│   │  Animal a = new Dog();                               │  │
│   │  a.speak();  // 运行时确定调用 Dog.speak()           │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   2. 编译时多态 (Compile-time Polymorphism)                 │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  • 方法重载实现                                      │  │
│   │  • 静态绑定，编译时确定                              │  │
│   │                                                     │  │
│   │  void print(int x) { }                               │  │
│   │  void print(String s) { }                            │  │
│   │  print(1);    // 编译时确定调用 print(int)           │  │
│   │  print("hi"); // 编译时确定调用 print(String)        │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 多态的优势

```
┌─────────────────────────────────────────────────────────────┐
│                    多态的优势                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. 可扩展性                                                │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  // 新增 Bird 类，无需修改 makeSpeak 方法            │  │
│   │  class Bird extends Animal {                         │  │
│   │      @Override                                       │  │
│   │      public void speak() { print("Chirp!"); }        │  │
│   │  }                                                   │  │
│   │  makeSpeak(new Bird());  // 直接可用                 │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   2. 代码复用                                                │
│      └── 一个方法处理多种类型                               │
│                                                             │
│   3. 解耦                                                    │
│      └── 调用者只依赖接口/父类，不依赖具体实现              │
│                                                             │
│   4. 符合开闭原则                                            │
│      └── 对扩展开放，对修改关闭                             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 注意事项

```java
Animal animal = new Dog();

// ✅ 可以调用: 父类中声明的方法
animal.speak();  // 多态，调用子类实现
animal.eat();    // 调用父类方法（子类未重写）

// ❌ 不能调用: 子类特有的方法
// animal.fetch();  // 编译错误！Animal 中没有 fetch()

// 如需调用子类特有方法，需要向下转型
if (animal instanceof Dog) {
    Dog dog = (Dog) animal;
    dog.fetch();  // OK
}

// Java 16+ 模式匹配
if (animal instanceof Dog dog) {
    dog.fetch();  // 更简洁
}
```

## 面试回答

### 30秒版本

> **多态**是指同一行为具有多个不同表现形式。三个必要条件：1）继承关系；2）方法重写；3）父类引用指向子类对象。运行时根据实际对象类型确定调用哪个方法（动态绑定）。优势：可扩展性好、代码复用、解耦、符合开闭原则。注意：通过父类引用只能调用父类声明的方法，调用子类特有方法需要向下转型。

### 1分钟版本

> **多态定义**：
> - 父类引用指向子类对象
> - 调用方法时执行子类的实现
>
> **三个条件**：
> 1. 继承关系或实现接口
> 2. 子类重写父类方法
> 3. 父类引用指向子类对象
>
> **两种类型**：
> - 运行时多态：方法重写，动态绑定
> - 编译时多态：方法重载，静态绑定
>
> **优势**：
> - 可扩展：新增子类不改调用代码
> - 解耦：依赖接口不依赖实现
> - 符合开闭原则
>
> **注意**：
> - 父类引用不能调用子类特有方法
> - 需要时使用 instanceof + 向下转型

---

*关联文档：[overload-vs-override.md](overload-vs-override.md) | [interface-vs-abstract.md](interface-vs-abstract.md)*
