# Java 中 wait() 和 sleep() 的区别？

## 核心区别

```
┌─────────────────────────────────────────────────────────────┐
│                    wait() vs sleep()                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │   wait()                                             │  │
│   │   ──────                                             │  │
│   │   • 属于 Object 类                                   │  │
│   │   • 必须在 synchronized 中调用                       │  │
│   │   • 释放锁                                           │  │
│   │   • 用于线程间通信                                   │  │
│   │   • 被 notify()/notifyAll() 唤醒                     │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │   sleep()                                            │  │
│   │   ────────                                           │  │
│   │   • 属于 Thread 类                                   │  │
│   │   • 任何地方都能调用                                 │  │
│   │   • 不释放锁                                         │  │
│   │   • 用于暂停执行                                     │  │
│   │   • 时间到自动唤醒                                   │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 对比表

```
┌─────────────────────────────────────────────────────────────┐
│                    对比总结                                  │
├──────────────────┬──────────────────┬───────────────────────┤
│   特性           │   wait()         │   sleep()             │
├──────────────────┼──────────────────┼───────────────────────┤
│   所属类         │   Object         │   Thread              │
│   是否释放锁     │   释放           │   不释放              │
│   调用条件       │   必须在同步块中 │   任何地方            │
│   唤醒方式       │   notify/超时    │   超时自动            │
│   用途           │   线程通信       │   暂停执行            │
│   异常           │   InterruptedException                   │
│   是否是静态方法 │   否             │   是                  │
└──────────────────┴──────────────────┴───────────────────────┘
```

## 代码示例

### wait() 示例

```java
public class WaitExample {
    private static final Object lock = new Object();
    private static boolean ready = false;
    
    public static void main(String[] args) {
        // 等待线程
        Thread waiter = new Thread(() -> {
            synchronized (lock) {
                while (!ready) {
                    try {
                        System.out.println("等待中...");
                        lock.wait();  // 释放锁，进入等待
                        System.out.println("被唤醒!");
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        
        // 通知线程
        Thread notifier = new Thread(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {}
            
            synchronized (lock) {
                ready = true;
                lock.notify();  // 唤醒等待的线程
            }
        });
        
        waiter.start();
        notifier.start();
    }
}
```

### sleep() 示例

```java
public class SleepExample {
    private static final Object lock = new Object();
    
    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            synchronized (lock) {
                System.out.println("T1 获得锁");
                try {
                    Thread.sleep(2000);  // 睡眠但不释放锁
                } catch (InterruptedException e) {}
                System.out.println("T1 释放锁");
            }
        });
        
        Thread t2 = new Thread(() -> {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {}
            
            synchronized (lock) {  // 等待 T1 释放锁
                System.out.println("T2 获得锁");
            }
        });
        
        t1.start();
        t2.start();
        // 输出: T1 获得锁 → (2秒后) T1 释放锁 → T2 获得锁
    }
}
```

## 释放锁的区别

```
┌─────────────────────────────────────────────────────────────┐
│                    锁释放行为对比                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   wait() 释放锁:                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │   Thread-1            Thread-2                       │  │
│   │   ─────────           ─────────                      │  │
│   │   获取锁                                             │  │
│   │   wait() ──释放锁──→ 获取锁                         │  │
│   │   等待中...          执行...                         │  │
│   │   ←──notify()─────── 执行完毕                        │  │
│   │   重新获取锁                                         │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   sleep() 不释放锁:                                          │
│   ┌─────────────────────────────────────────────────────┐  │
│   │   Thread-1            Thread-2                       │  │
│   │   ─────────           ─────────                      │  │
│   │   获取锁                                             │  │
│   │   sleep() ──持有锁    等待锁... (被阻塞)             │  │
│   │   睡眠中...           等待锁...                      │  │
│   │   睡醒，继续执行      等待锁...                      │  │
│   │   释放锁 ───────────→ 获取锁                         │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 使用场景

```
┌─────────────────────────────────────────────────────────────┐
│                    使用场景                                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   wait():                                                    │
│   • 生产者-消费者模式                                       │
│   • 等待某个条件满足                                        │
│   • 线程间协调                                              │
│                                                             │
│   sleep():                                                   │
│   • 定时任务                                                │
│   • 轮询间隔                                                │
│   • 模拟延迟                                                │
│                                                             │
│   最佳实践:                                                  │
│   • wait() 放在 while 循环中 (防止虚假唤醒)                 │
│   • 优先使用 java.util.concurrent 工具类                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 面试回答

### 30秒版本

> **wait()** 属于 Object 类，必须在 synchronized 中调用，**会释放锁**，用于线程通信，由 notify() 唤醒。**sleep()** 属于 Thread 类，任何地方都能调用，**不释放锁**，用于暂停执行，时间到自动唤醒。两者都会抛 InterruptedException。

### 1分钟版本

> **所属类**：
> - wait()：Object 类
> - sleep()：Thread 类（静态方法）
>
> **锁释放**：
> - wait()：释放锁，让其他线程执行
> - sleep()：持有锁，其他线程等待
>
> **调用条件**：
> - wait()：必须在 synchronized 块中
> - sleep()：任何地方
>
> **唤醒方式**：
> - wait()：notify()/notifyAll()/超时
> - sleep()：超时自动唤醒
>
> **用途**：
> - wait()：线程间通信
> - sleep()：暂停执行

---

*关联文档：[thread-lifecycle.md](../05-concurrency/thread-lifecycle.md)*
