# 什么是 Java 中的双亲委派模型？

## 双亲委派模型概述

```
┌─────────────────────────────────────────────────────────────┐
│                    双亲委派模型                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   定义: 类加载时先委托父加载器加载，父加载器无法加载时      │
│        才由自己加载                                         │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │                                                     │  │
│   │   ┌─────────────────────────────────────────────┐  │  │
│   │   │        Bootstrap ClassLoader                │  │  │
│   │   │        (启动类加载器)                        │  │  │
│   │   │        加载: rt.jar, java.* 核心类          │  │  │
│   │   └───────────────────┬─────────────────────────┘  │  │
│   │                       │ 父                          │  │
│   │   ┌───────────────────▼─────────────────────────┐  │  │
│   │   │        Extension ClassLoader                │  │  │
│   │   │        (扩展类加载器)                        │  │  │
│   │   │        加载: jre/lib/ext 目录               │  │  │
│   │   └───────────────────┬─────────────────────────┘  │  │
│   │                       │ 父                          │  │
│   │   ┌───────────────────▼─────────────────────────┐  │  │
│   │   │        Application ClassLoader              │  │  │
│   │   │        (应用类加载器)                        │  │  │
│   │   │        加载: classpath 用户类               │  │  │
│   │   └───────────────────┬─────────────────────────┘  │  │
│   │                       │ 父                          │  │
│   │   ┌───────────────────▼─────────────────────────┐  │  │
│   │   │        Custom ClassLoader                   │  │  │
│   │   │        (自定义类加载器)                      │  │  │
│   │   └─────────────────────────────────────────────┘  │  │
│   │                                                     │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 加载流程

```
┌─────────────────────────────────────────────────────────────┐
│                    类加载流程                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   加载请求: 加载 com.example.MyClass                        │
│                                                             │
│   1. Application 收到请求                                   │
│      └── 委托给父加载器 Extension                           │
│                                                             │
│   2. Extension 收到请求                                     │
│      └── 委托给父加载器 Bootstrap                           │
│                                                             │
│   3. Bootstrap 尝试加载                                     │
│      └── rt.jar 中没有 → 返回失败                           │
│                                                             │
│   4. Extension 自己尝试加载                                 │
│      └── ext 目录没有 → 返回失败                            │
│                                                             │
│   5. Application 自己加载                                   │
│      └── classpath 中找到 → 加载成功                        │
│                                                             │
│   流程: 向上委托 → 向下加载                                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 源码实现

```java
// ClassLoader.loadClass() 核心代码
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException {
    
    synchronized (getClassLoadingLock(name)) {
        // 1. 检查是否已加载
        Class<?> c = findLoadedClass(name);
        
        if (c == null) {
            try {
                // 2. 委托父加载器加载
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    // Bootstrap 加载器
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // 父加载器无法加载
            }
            
            if (c == null) {
                // 3. 父加载器无法加载，自己加载
                c = findClass(name);
            }
        }
        return c;
    }
}
```

## 双亲委派的好处

```
┌─────────────────────────────────────────────────────────────┐
│                    双亲委派的好处                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. 安全性                                                  │
│      └── 防止核心类被篡改                                   │
│      └── 自定义 java.lang.String 不会被加载                 │
│                                                             │
│   2. 避免重复加载                                            │
│      └── 父加载器已加载的类不会重复加载                     │
│      └── 保证类的唯一性                                     │
│                                                             │
│   3. 保证核心类优先                                          │
│      └── 核心 API 由 Bootstrap 加载                         │
│      └── 保证基础类库的一致性                               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 打破双亲委派

```java
// 方式1: 重写 loadClass() (不推荐)
public class MyClassLoader extends ClassLoader {
    @Override
    public Class<?> loadClass(String name) throws ClassNotFoundException {
        // 自己先加载，加载不了再委托父类
        try {
            return findClass(name);
        } catch (ClassNotFoundException e) {
            return super.loadClass(name);
        }
    }
}

// 方式2: 使用线程上下文类加载器 (SPI 机制)
// 父加载器需要加载子加载器的类时使用
ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();
Class<?> clazz = contextLoader.loadClass("com.example.SpiImpl");
```

## 打破双亲委派的场景

```
┌─────────────────────────────────────────────────────────────┐
│                    打破双亲委派的场景                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. JDBC                                                    │
│      └── DriverManager 在 rt.jar (Bootstrap 加载)           │
│      └── 具体驱动在 classpath (Application 加载)            │
│      └── 使用线程上下文类加载器加载驱动                     │
│                                                             │
│   2. Tomcat                                                  │
│      └── 每个 Web 应用使用独立的类加载器                    │
│      └── 实现应用隔离                                       │
│                                                             │
│   3. OSGi                                                    │
│      └── 模块化，每个模块独立类加载器                       │
│                                                             │
│   4. 热部署                                                  │
│      └── 动态加载新版本类                                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 面试回答

### 30秒版本

> 双亲委派：类加载时**先委托父加载器**，父加载器无法加载才自己加载。加载器层次：Bootstrap（核心类）→ Extension（扩展类）→ Application（用户类）。好处：**安全**（防核心类被篡改）、**避免重复加载**。SPI 场景会打破双亲委派，使用**线程上下文类加载器**。

### 1分钟版本

> **定义**：先委托父加载器，父无法加载才自己加载
>
> **类加载器层次**：
> - Bootstrap：加载 rt.jar 核心类
> - Extension：加载 ext 目录
> - Application：加载 classpath
>
> **流程**：向上委托 → 向下加载
>
> **好处**：
> - 安全：防止核心类被篡改
> - 避免重复加载
> - 保证核心类优先
>
> **打破场景**：
> - JDBC SPI
> - Tomcat 应用隔离
> - 热部署

---

*关联文档：[classloader.md](classloader.md) | [java-spi.md](java-spi.md)*
