# 为什么 Java 不支持多重继承？

## 多重继承的问题

```
┌─────────────────────────────────────────────────────────────┐
│                    菱形继承问题 (Diamond Problem)            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   C++ 允许多重继承，会产生菱形继承问题:                     │
│                                                             │
│                      ┌───────────┐                          │
│                      │  Animal   │                          │
│                      │  eat()    │                          │
│                      └─────┬─────┘                          │
│                   ┌────────┴────────┐                       │
│                   ▼                 ▼                       │
│              ┌─────────┐       ┌─────────┐                  │
│              │  Horse  │       │  Donkey │                  │
│              │  eat()  │       │  eat()  │                  │
│              └────┬────┘       └────┬────┘                  │
│                   │                 │                       │
│                   └────────┬────────┘                       │
│                            ▼                                │
│                      ┌───────────┐                          │
│                      │   Mule    │  骡子继承马和驴          │
│                      │  eat() ?  │  调用哪个 eat()？        │
│                      └───────────┘                          │
│                                                             │
│   问题:                                                      │
│   1. 歧义性: Mule 调用 eat() 时，调用哪个父类的？           │
│   2. 数据冗余: Animal 的属性在 Mule 中存在两份              │
│   3. 复杂性: 继承关系变得复杂难以维护                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## Java 的设计选择

```
┌─────────────────────────────────────────────────────────────┐
│                    Java 的解决方案                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   ✅ 单继承类 + 多实现接口                                   │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  // 只能继承一个类                                   │  │
│   │  class Dog extends Animal { }                        │  │
│   │                                                     │  │
│   │  // 可以实现多个接口                                 │  │
│   │  class Dog extends Animal                            │  │
│   │      implements Runnable, Comparable<Dog> { }        │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   为什么接口可以多实现？                                     │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  • 接口只有方法签名，没有实现（Java 8 之前）         │  │
│   │  • 即使方法同名，实现类只需提供一个实现              │  │
│   │  • 没有状态（成员变量），不存在数据冗余              │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## Java 8+ 默认方法的处理

```java
// Java 8 接口可以有默认方法，这也可能产生冲突

interface Flyable {
    default void move() {
        System.out.println("Fly in the sky");
    }
}

interface Swimmable {
    default void move() {
        System.out.println("Swim in the water");
    }
}

// 实现两个接口，两个接口都有 move() 默认方法
class Duck implements Flyable, Swimmable {
    
    // 必须重写 move()，解决冲突
    @Override
    public void move() {
        // 方式1: 自定义实现
        System.out.println("Duck can both fly and swim");
        
        // 方式2: 明确调用某个接口的默认方法
        Flyable.super.move();
        Swimmable.super.move();
    }
}
```

```
┌─────────────────────────────────────────────────────────────┐
│                    默认方法冲突解决规则                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. 类优先于接口                                            │
│      └── 如果父类有实现，优先使用父类的                     │
│                                                             │
│   2. 子接口优先于父接口                                      │
│      └── 更具体的接口优先                                   │
│                                                             │
│   3. 必须显式覆盖                                            │
│      └── 如果无法确定，编译器要求必须重写                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 多继承的替代方案

```
┌─────────────────────────────────────────────────────────────┐
│                    替代方案                                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. 接口 + 默认方法                                         │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  interface Loggable {                                │  │
│   │      default void log(String msg) {                  │  │
│   │          System.out.println(msg);                    │  │
│   │      }                                               │  │
│   │  }                                                   │  │
│   │  class MyService implements Loggable { ... }         │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   2. 组合优于继承                                            │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  class Duck {                                        │  │
│   │      private Flyable flyBehavior;      // 组合       │  │
│   │      private Swimmable swimBehavior;   // 组合       │  │
│   │                                                     │  │
│   │      void fly() { flyBehavior.fly(); }               │  │
│   │      void swim() { swimBehavior.swim(); }            │  │
│   │  }                                                   │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   3. 装饰器模式 / 代理模式                                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 面试回答

### 30秒版本

> Java 不支持多重继承主要是为了避免**菱形继承问题**：当两个父类有相同方法时，子类不知道调用哪个。Java 用**单继承类 + 多实现接口**解决，因为接口只有方法签名没有实现。Java 8 的默认方法可能产生冲突，此时必须显式重写。实际开发中推荐**组合优于继承**。

### 1分钟版本

> **为什么不支持**：
> - 菱形继承问题 (Diamond Problem)
> - 两个父类有相同方法，子类不知道调用哪个
> - 可能导致数据冗余
> - 继承关系复杂难维护
>
> **Java 的方案**：
> - 单继承类 + 多实现接口
> - 接口没有状态，不存在数据冗余
> - 接口只有方法签名（Java 8 前），不存在歧义
>
> **Java 8+ 默认方法冲突**：
> - 如果两个接口有相同默认方法
> - 必须在实现类中显式重写
> - 可以用 `Interface.super.method()` 调用特定接口
>
> **替代方案**：
> - 组合优于继承
> - 装饰器模式

---

*关联文档：[interface-vs-abstract.md](interface-vs-abstract.md) | [java-polymorphism.md](java-polymorphism.md)*
