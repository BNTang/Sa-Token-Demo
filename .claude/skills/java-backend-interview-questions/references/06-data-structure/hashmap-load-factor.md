# 为什么 Java 中 HashMap 的默认负载因子是 0.75？

## 负载因子概念

```
┌─────────────────────────────────────────────────────────────┐
│                    负载因子 (Load Factor)                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   定义: threshold = capacity × loadFactor                   │
│        当 size > threshold 时触发扩容                       │
│                                                             │
│   默认值: 0.75                                               │
│   默认容量: 16                                               │
│   默认阈值: 16 × 0.75 = 12                                   │
│                                                             │
│   含义: 当填充了 75% 时扩容                                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 0.75 的权衡

```
┌─────────────────────────────────────────────────────────────┐
│                    空间与时间的权衡                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   负载因子太小 (如 0.5):                                     │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  ✓ 碰撞少，查询快                                    │  │
│   │  ✗ 空间利用率低，频繁扩容                            │  │
│   │  ✗ 内存浪费                                          │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   负载因子太大 (如 1.0):                                     │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  ✓ 空间利用率高                                      │  │
│   │  ✗ 碰撞多，链表长，查询慢                            │  │
│   │  ✗ 性能下降                                          │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   0.75 是经验最优值:                                         │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  ✓ 空间利用率适中 (~75%)                             │  │
│   │  ✓ 碰撞概率可接受                                    │  │
│   │  ✓ 时间和空间平衡                                    │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 泊松分布分析

```
┌─────────────────────────────────────────────────────────────┐
│                    泊松分布与碰撞概率                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   HashMap 源码注释:                                          │
│   Ideally, under random hashCodes, the frequency of         │
│   nodes in bins follows a Poisson distribution              │
│   (http://en.wikipedia.org/wiki/Poisson_distribution)       │
│   with a parameter of about 0.5 on average for the         │
│   default resizing threshold of 0.75.                       │
│                                                             │
│   负载因子 0.75 时，每个桶的平均元素数 λ ≈ 0.5               │
│                                                             │
│   桶中元素个数的概率分布 (泊松分布):                         │
│   ┌───────────────────────────────────────────────────┐    │
│   │  元素数  │  概率                                  │    │
│   │  0       │  0.60653066                            │    │
│   │  1       │  0.30326533                            │    │
│   │  2       │  0.07581633                            │    │
│   │  3       │  0.01263606                            │    │
│   │  4       │  0.00157952                            │    │
│   │  5       │  0.00015795                            │    │
│   │  6       │  0.00001316                            │    │
│   │  7       │  0.00000094                            │    │
│   │  8       │  0.00000006 (亿分之一)                 │    │
│   └───────────────────────────────────────────────────┘    │
│                                                             │
│   链表长度达到 8 的概率极低 (亿分之一)                       │
│   这也是链表转红黑树阈值选 8 的原因                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 不同负载因子对比

```
┌─────────────────────────────────────────────────────────────┐
│                    不同负载因子效果                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   存储 100 万个元素:                                         │
│                                                             │
│   负载因子   容量需求      碰撞率      内存占用               │
│   ─────────  ─────────    ─────────   ─────────              │
│   0.5        200万        低          高                     │
│   0.75       133万        中          中                     │
│   1.0        100万        高          低                     │
│                                                             │
│   负载因子   平均查询     扩容次数    推荐场景               │
│   ─────────  ─────────    ─────────   ─────────              │
│   0.5        O(1)         多          时间敏感               │
│   0.75       O(1)~O(1.x)  适中        通用                   │
│   1.0        O(1)~O(n)    少          空间敏感               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 源码定义

```java
/**
 * The load factor used when none specified in constructor.
 */
static final float DEFAULT_LOAD_FACTOR = 0.75f;

// 可自定义负载因子
public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException("...");
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("...");
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
}

// 使用示例
// 时间敏感场景
Map<String, Object> map = new HashMap<>(16, 0.5f);

// 空间敏感场景
Map<String, Object> map = new HashMap<>(16, 0.9f);
```

## 为什么是 0.75 而不是 0.7 或 0.8？

```
┌─────────────────────────────────────────────────────────────┐
│                    为什么是 0.75？                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. 数学推导:                                               │
│      在理想 hash 分布下，0.75 使碰撞概率最优                │
│      桶中平均 0.5 个元素，链表长度大多为 0 或 1             │
│                                                             │
│   2. 经验值:                                                 │
│      大量实验表明 0.7~0.8 范围都不错                        │
│      0.75 是折中值                                          │
│                                                             │
│   3. 计算友好:                                               │
│      0.75 = 3/4，可以用位运算优化                           │
│      threshold = (capacity * 3) >> 2                        │
│                                                             │
│   4. 兼容性:                                                 │
│      与容量 2^n 配合良好                                    │
│      16 * 0.75 = 12 (整数)                                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 面试回答

### 30秒版本

> 0.75 是**时间与空间的最优权衡**。太小（如0.5）空间浪费、频繁扩容；太大（如1.0）碰撞多、查询慢。0.75 时根据泊松分布，链表长度大多是 0-2，链表达到 8 的概率是亿分之一。另外 0.75=3/4 可用位运算优化，且与 2^n 容量配合良好。

### 1分钟版本

> **权衡空间与时间**：
> - 太小：空间浪费，频繁扩容
> - 太大：碰撞多，链表长，查询慢
> - 0.75 是平衡点
>
> **泊松分布验证**：
> - λ = 0.5 时最优
> - 大部分桶 0-2 个元素
> - 链表达 8 概率是亿分之一
>
> **其他原因**：
> - 0.75 = 3/4，位运算优化
> - 与 2^n 容量配合好
> - 大量实验验证的经验值
>
> **可自定义**：时间敏感用 0.5，空间敏感用 0.9

---

*关联文档：[hashmap-resize.md](hashmap-resize.md) | [hashmap-principle.md](hashmap-principle.md)*
