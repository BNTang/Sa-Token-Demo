# 为什么 HashMap 在 Java 中扩容时采用 2 的 n 次方倍？

## 核心原因

```
┌─────────────────────────────────────────────────────────────┐
│                    为什么是 2^n？                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. 位运算取模: (n-1) & hash 替代 hash % n                 │
│   2. 扩容优化: 只看高位，无需重新计算 hash                  │
│   3. 均匀分布: 2^n - 1 的二进制全是 1，分布均匀             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 原因一：位运算取模

```
┌─────────────────────────────────────────────────────────────┐
│                    位运算优化                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   普通取模:                                                  │
│   index = hash % n     // 效率低，除法运算                  │
│                                                             │
│   位运算取模 (n 为 2^k 时等价):                              │
│   index = hash & (n-1)  // 效率高，位与运算                 │
│                                                             │
│   证明 (n = 16 = 2^4):                                       │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  n = 16     = 10000 (二进制)                        │  │
│   │  n-1 = 15   = 01111 (二进制)                        │  │
│   │                                                     │  │
│   │  hash = 19  = 10011                                 │  │
│   │  19 % 16 = 3                                        │  │
│   │  19 & 15 = 10011 & 01111 = 00011 = 3 ✓             │  │
│   │                                                     │  │
│   │  结论: 当 n = 2^k 时，hash & (n-1) == hash % n      │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   性能: & 运算比 % 快 5-10 倍                                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 原因二：扩容高效

```
┌─────────────────────────────────────────────────────────────┐
│                    扩容位置计算优化                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   容量翻倍后，元素要么在原位置，要么在 原位置 + 旧容量      │
│   只需判断 hash 的高位是 0 还是 1                           │
│                                                             │
│   示例 (扩容 16 → 32):                                       │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  oldCap = 16  = 10000                               │  │
│   │  newCap = 32  = 100000                              │  │
│   │                                                     │  │
│   │  hash = 5  = 00101                                  │  │
│   │  old: 5 & 15 = 00101 & 01111 = 00101 = 5            │  │
│   │  new: 5 & 31 = 00101 & 11111 = 00101 = 5            │  │
│   │  高位 = 5 & 16 = 00101 & 10000 = 0 → 位置不变       │  │
│   │                                                     │  │
│   │  hash = 21 = 10101                                  │  │
│   │  old: 21 & 15 = 10101 & 01111 = 00101 = 5           │  │
│   │  new: 21 & 31 = 10101 & 11111 = 10101 = 21          │  │
│   │  高位 = 21 & 16 = 10101 & 10000 = 16 ≠ 0            │  │
│   │  → 新位置 = 5 + 16 = 21 ✓                           │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   无需重新计算 hash，只需判断一位                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 原因三：均匀分布

```
┌─────────────────────────────────────────────────────────────┐
│                    均匀分布                                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   n-1 二进制全是 1，可以充分利用 hash 的低位               │
│                                                             │
│   n = 16:  n-1 = 15 = 01111                                 │
│   n = 32:  n-1 = 31 = 11111                                 │
│                                                             │
│   假如 n = 15 (非 2^k):                                      │
│   n-1 = 14 = 01110                                          │
│                                                             │
│   hash = 9  = 01001                                         │
│   hash = 17 = 10001                                         │
│   9 & 14  = 01001 & 01110 = 01000 = 8                       │
│   17 & 14 = 10001 & 01110 = 00000 = 0                       │
│                                                             │
│   问题: 最低位是 0，永远不参与运算                          │
│   结果: 分布不均，位置 1,3,5,7,9,11,13,15 永远没有元素      │
│                                                             │
│   当 n = 2^k 时，n-1 全是 1，每一位都参与运算               │
│   分布更均匀，碰撞更少                                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 源码验证

```java
// HashMap 源码

// 确保容量是 2^n
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}

// 示例
// 输入 10 → 输出 16
// 输入 17 → 输出 32

// 定位桶位置 (位运算取模)
int index = (n - 1) & hash;

// 扩容时判断高位
if ((e.hash & oldCap) == 0) {
    // 位置不变
} else {
    // 新位置 = 原位置 + oldCap
}
```

## 性能对比

```
┌─────────────────────────────────────────────────────────────┐
│                    性能对比                                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   操作              普通取模 (%)      位运算 (&)            │
│   ─────             ────────────      ────────────          │
│   1000万次定位      ~500ms            ~50ms                 │
│   扩容迁移          需重新计算hash    只判断高位            │
│                                                             │
│   整体性能提升: 5-10 倍                                      │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 面试回答

### 30秒版本

> HashMap 容量是 2^n 有三个原因：①**位运算取模**：`hash & (n-1)` 替代 `hash % n`，速度快 5-10 倍；②**扩容优化**：元素位置只看 hash 高位是 0 还是 1，无需重新计算；③**均匀分布**：n-1 全是 1，充分利用 hash 低位，碰撞更少。

### 1分钟版本

> **位运算取模**：
> - 当 n = 2^k 时
> - hash & (n-1) == hash % n
> - 位运算比取模快 5-10 倍
>
> **扩容优化**：
> - 容量翻倍后
> - 只看 hash 高位 (hash & oldCap)
> - 为 0 位置不变
> - 为 1 位置 = 原位置 + oldCap
>
> **均匀分布**：
> - n-1 二进制全是 1
> - 每一位都参与计算
> - 分布更均匀
>
> **源码保证**：tableSizeFor() 确保容量是 2^n

---

*关联文档：[hashmap-resize.md](hashmap-resize.md) | [hashmap-principle.md](hashmap-principle.md)*
