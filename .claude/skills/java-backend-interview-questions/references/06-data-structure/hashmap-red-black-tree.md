# 为什么 JDK 1.8 对 HashMap 进行了红黑树的改动？

> 解决链表过长导致的查询性能退化问题，将最坏时间复杂度从 O(n) 优化到 O(log n)

## 30秒速答

JDK 1.8 引入红黑树是为了解决**哈希冲突严重时链表过长**导致的性能问题：
- **问题**: 链表查询时间复杂度 O(n)，极端情况退化为线性表
- **解决**: 链表长度 ≥ 8 且数组长度 ≥ 64 时，转换为红黑树
- **效果**: 查询时间复杂度优化到 O(log n)

## 一分钟详解

### 为什么需要红黑树？

```
JDK 1.7 哈希冲突严重时：
┌─────────────────────────────────────┐
│  bucket[i] → A → B → C → D → E → F │  链表长度 n
│                                     │
│  查找 F: 遍历 6 次                   │  时间复杂度 O(n)
│  最坏情况: 所有元素在同一桶           │  退化成线性表
└─────────────────────────────────────┘

JDK 1.8 红黑树优化：
┌─────────────────────────────────────┐
│  bucket[i] →      D                 │
│                 /   \               │
│                B     E              │  红黑树
│               / \     \             │
│              A   C     F            │  时间复杂度 O(log n)
│                                     │
│  查找 F: 最多 3 次比较               │
└─────────────────────────────────────┘
```

### 转换条件

```java
// 链表转红黑树的两个条件
static final int TREEIFY_THRESHOLD = 8;    // 链表长度阈值
static final int MIN_TREEIFY_CAPACITY = 64; // 数组最小容量

// 转换时机判断 (putVal 方法中)
if (binCount >= TREEIFY_THRESHOLD - 1) {  // 链表长度 ≥ 8
    treeifyBin(tab, hash);  // 尝试树化
}

// treeifyBin 方法
final void treeifyBin(Node<K,V>[] tab, int hash) {
    if (tab == null || tab.length < MIN_TREEIFY_CAPACITY) {
        resize();  // 数组 < 64，优先扩容而非树化
    } else {
        // 执行链表→红黑树转换
    }
}
```

### 为什么阈值是 8？

```
泊松分布概率计算（负载因子 0.75）：
┌────────────────────────────────────────┐
│  链表长度    概率                       │
│     0       0.60653066                 │
│     1       0.30326533                 │
│     2       0.07581633                 │
│     3       0.01263606                 │
│     4       0.00157952                 │
│     5       0.00015795                 │
│     6       0.00001316                 │
│     7       0.00000094                 │
│     8       0.00000006  ← 千万分之六   │
└────────────────────────────────────────┘

结论：正常使用下链表达到 8 的概率极低
      但遇到恶意哈希攻击时，红黑树能保护性能
```

### 红黑树退化为链表

```java
// 红黑树退化阈值
static final int UNTREEIFY_THRESHOLD = 6;

// 扩容时如果红黑树节点 ≤ 6，退化为链表
if (lc <= UNTREEIFY_THRESHOLD) {
    tab[index] = loHead.untreeify(map);
}
```

### 性能对比

| 操作 | 链表 O(n) | 红黑树 O(log n) | n=1000 时 |
|------|-----------|-----------------|-----------|
| 查找 | 1000 次 | 10 次 | 100倍提升 |
| 插入 | 1000 次 | 10 次 | 100倍提升 |
| 删除 | 1000 次 | 10 次 | 100倍提升 |

## 关键记忆点

```
┌─────────────────────────────────────────────────┐
│  红黑树改动三要素：                               │
│                                                 │
│  1. 目的：解决链表过长 O(n) → O(log n)           │
│  2. 条件：链表 ≥ 8 且 数组 ≥ 64                  │
│  3. 退化：扩容后节点 ≤ 6 退回链表                 │
│                                                 │
│  为什么是 8？                                    │
│  泊松分布概率极低 + 防御哈希攻击                  │
└─────────────────────────────────────────────────┘
```

## 面试加分项

1. **为什么不一开始就用红黑树？**
   - 红黑树节点占用空间是链表的 2 倍
   - 红黑树维护成本高（旋转、变色）
   - 链表短时性能差异不大

2. **为什么用红黑树不用 AVL 树？**
   - 红黑树插入删除旋转次数少（最多 3 次）
   - AVL 树过于严格平衡，维护成本高
   - HashMap 增删频繁，红黑树更合适

3. **哈希攻击是什么？**
   - 恶意构造大量相同 hashCode 的 key
   - 导致所有元素落入同一桶，退化成 O(n)
   - 红黑树能将攻击影响降到 O(log n)
