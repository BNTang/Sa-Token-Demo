# JDK 1.8 对 HashMap 除了红黑树还有哪些改动？

> JDK 1.8 对 HashMap 进行了全面优化，包括数据结构、扩容机制、哈希算法等多方面改进

## 30秒速答

JDK 1.8 HashMap 主要改动：
1. **红黑树**: 链表 ≥ 8 转红黑树，O(n) → O(log n)
2. **扩容优化**: 不再重新计算 hash，用高位判断新位置
3. **插入方式**: 头插法改为**尾插法**，避免死循环
4. **哈希算法**: 扰动函数简化，从 4 次位运算减到 1 次

## 一分钟详解

### 1. 数据结构改动

```
JDK 1.7: 数组 + 链表
┌───┬───┬───┬───┬───┬───┬───┬───┐
│ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │
└─┬─┴───┴─┬─┴───┴───┴─┬─┴───┴───┘
  ↓       ↓           ↓
  A       C           E
  ↓       ↓
  B       D

JDK 1.8: 数组 + 链表 + 红黑树
┌───┬───┬───┬───┬───┬───┬───┬───┐
│ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │
└─┬─┴───┴─┬─┴───┴───┴─┬─┴───┴───┘
  ↓       ↓           ↓
  A      [红黑树]      E
  ↓       
  B       
```

### 2. 插入方式改动（重要！）

```java
// JDK 1.7 头插法（并发死循环风险）
void addEntry(int hash, K key, V value, int bucketIndex) {
    Entry<K,V> e = table[bucketIndex];
    table[bucketIndex] = new Entry<>(hash, key, value, e);  // 新节点在头部
}

// JDK 1.8 尾插法（解决死循环）
for (int binCount = 0; ; ++binCount) {
    if ((e = p.next) == null) {
        p.next = newNode(hash, key, value, null);  // 新节点在尾部
        break;
    }
    p = e;
}
```

**头插法死循环原因：**
```
并发扩容时：
线程1：A → B → null（扩容中）
线程2：B → A → null（扩容后指针反转）

合并后形成环：A ⇄ B（get时死循环）
```

### 3. 扩容优化

```java
// JDK 1.7: 每个元素重新计算 hash 和位置
for (Entry<K,V> e : table) {
    int i = indexFor(e.hash, newCapacity);  // 重新计算
}

// JDK 1.8: 用 hash & oldCap 判断高位
// 新位置 = 原位置 或 原位置 + oldCap
if ((e.hash & oldCap) == 0) {
    // 留在原位置 (低位链表)
} else {
    // 移到 原位置 + oldCap (高位链表)
}
```

**扩容位置判断原理：**
```
假设 oldCap = 16, hash = 17 (二进制: 10001)

扩容前: hash & (16-1) = 10001 & 01111 = 00001 = 位置 1
扩容后: hash & (32-1) = 10001 & 11111 = 10001 = 位置 17

关键：只需看 hash 的第 5 位 (oldCap 对应位)
     hash & oldCap = 10001 & 10000 = 10000 ≠ 0
     新位置 = 1 + 16 = 17 ✓
```

### 4. 哈希算法简化

```java
// JDK 1.7: 4 次扰动
static int hash(int h) {
    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}

// JDK 1.8: 1 次扰动（高16位异或低16位）
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

**简化原因：**
- 红黑树兜底，极端冲突也是 O(log n)
- 一次扰动已足够分散
- 减少计算开销

### 5. 其他改动

| 改动项 | JDK 1.7 | JDK 1.8 |
|--------|---------|---------|
| 数据结构 | 数组+链表 | 数组+链表+红黑树 |
| 插入方式 | 头插法 | 尾插法 |
| 扩容计算 | 重新hash | 高位判断 |
| 哈希扰动 | 4次位运算 | 1次异或 |
| 初始化 | 构造时初始化数组 | 首次put时初始化 |

## 关键记忆点

```
┌────────────────────────────────────────────┐
│  JDK 1.8 HashMap 改动速记：                 │
│                                            │
│  「树」链表 ≥ 8 转红黑树                    │
│  「尾」头插法改尾插法（防死循环）            │
│  「位」扩容用高位判断（不重新hash）          │
│  「简」扰动函数简化 4次 → 1次               │
│  「延」延迟初始化（首次put才创建数组）       │
└────────────────────────────────────────────┘
```

## 对比表

```
┌─────────────┬────────────────────┬────────────────────┐
│   特性       │      JDK 1.7       │      JDK 1.8       │
├─────────────┼────────────────────┼────────────────────┤
│ 最坏查询    │      O(n)          │      O(log n)      │
│ 并发扩容    │      死循环风险     │      安全(尾插)    │
│ 扩容效率    │      低(重算hash)   │      高(位判断)    │
│ 内存占用    │      较少           │      略多(树节点)  │
└─────────────┴────────────────────┴────────────────────┘
```

## 面试追问

**Q: JDK 1.8 的尾插法能解决并发问题吗？**

A: 不能！尾插法只解决了**死循环**问题，HashMap 仍然**线程不安全**：
- 可能丢失数据（覆盖写入）
- 可能读到不一致数据
- 并发场景应该用 ConcurrentHashMap
