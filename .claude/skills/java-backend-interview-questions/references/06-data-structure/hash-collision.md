# 什么是 Hash 碰撞？怎么解决哈希碰撞？

## Hash 碰撞定义

```
┌─────────────────────────────────────────────────────────────┐
│                    Hash 碰撞 (Hash Collision)                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   定义: 不同的 key 计算出相同的 hash 值                     │
│                                                             │
│   示例:                                                      │
│   "Aa".hashCode() = 2112                                    │
│   "BB".hashCode() = 2112                                    │
│                                                             │
│   ┌─────────────────────────────────────────────────────┐  │
│   │                                                     │  │
│   │    Key1 ─────────┐                                  │  │
│   │                  ├───→ Hash = 100 ───→ 同一个桶     │  │
│   │    Key2 ─────────┘                                  │  │
│   │                                                     │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   原因: hash 空间有限，key 空间无限                         │
│        鸽巢原理: n+1 只鸽子放 n 个笼子必有一笼多只          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 解决方案

```
┌─────────────────────────────────────────────────────────────┐
│                    四种解决方案                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. 链地址法 (Separate Chaining)  ← HashMap 使用           │
│   2. 开放地址法 (Open Addressing)  ← ThreadLocalMap 使用    │
│   3. 再哈希法 (Rehashing)                                   │
│   4. 建立公共溢出区                                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 1. 链地址法 (HashMap 使用)

```
┌─────────────────────────────────────────────────────────────┐
│                    链地址法                                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   同一个桶的元素用链表/红黑树连接                           │
│                                                             │
│   ┌─────┬─────┬─────┬─────┬─────┐                          │
│   │  0  │  1  │  2  │  3  │  4  │  数组                    │
│   ├─────┼─────┼─────┼─────┼─────┤                          │
│   │     │Node │     │Node │     │                          │
│   └─────┴──┬──┴─────┴──┬──┴─────┘                          │
│            │           │                                    │
│            ↓           ↓                                    │
│         ┌────┐      ┌────┐                                 │
│         │ A  │      │ D  │  链表                           │
│         └──┬─┘      └──┬─┘                                 │
│            ↓           ↓                                    │
│         ┌────┐      ┌────┐                                 │
│         │ B  │      │ E  │                                 │
│         └──┬─┘      └────┘                                 │
│            ↓                                                │
│         ┌────┐      JDK 8+: 链表长度≥8 转红黑树            │
│         │ C  │                                             │
│         └────┘                                             │
│                                                             │
│   优点: 简单，删除方便                                      │
│   缺点: 链表过长性能差 (JDK8 用红黑树优化)                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2. 开放地址法 (线性探测)

```
┌─────────────────────────────────────────────────────────────┐
│                    开放地址法                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   冲突时寻找下一个空位                                      │
│                                                             │
│   线性探测: hash(k) + 1, hash(k) + 2, ...                   │
│   二次探测: hash(k) + 1², hash(k) + 2², ...                 │
│   双重哈希: hash1(k) + i * hash2(k)                         │
│                                                             │
│   示例 (线性探测):                                           │
│   ┌─────┬─────┬─────┬─────┬─────┐                          │
│   │  0  │  1  │  2  │  3  │  4  │                          │
│   ├─────┼─────┼─────┼─────┼─────┤                          │
│   │  A  │  B  │  C  │     │     │                          │
│   └─────┴─────┴─────┴─────┴─────┘                          │
│                                                             │
│   插入 D (hash=0):                                          │
│   位置 0 被占 → 位置 1 被占 → 位置 2 被占 → 位置 3 插入     │
│                                                             │
│   优点: 内存利用率高                                        │
│   缺点: 删除麻烦，容易聚集                                  │
│                                                             │
│   ThreadLocalMap 使用此方法                                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 3. 再哈希法

```java
// 使用多个不同的 hash 函数
int hash1 = hashFunc1(key);
if (collision) {
    int hash2 = hashFunc2(key);
    if (collision) {
        int hash3 = hashFunc3(key);
        // ...
    }
}

// 缺点: 计算时间增加
```

### 4. 建立公共溢出区

```
┌─────────────────────────────────────────────────────────────┐
│   基本区                        溢出区                      │
│   ┌─────┬─────┬─────┐          ┌─────┬─────┬─────┐         │
│   │  A  │  B  │  C  │          │ A'  │ B'  │     │         │
│   └─────┴─────┴─────┘          └─────┴─────┴─────┘         │
│                                                             │
│   冲突的元素放入公共溢出区                                  │
└─────────────────────────────────────────────────────────────┘
```

## HashMap 具体实现

```java
// JDK 8 HashMap 处理碰撞

// 1. 扰动函数 - 减少碰撞
static final int hash(Object key) {
    int h;
    // 高16位参与运算，让 hash 更均匀
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

// 2. 链表 + 红黑树
final V putVal(int hash, K key, V value, ...) {
    // ...
    if (桶为空) {
        直接插入;
    } else if (是红黑树) {
        红黑树插入;
    } else {
        // 链表
        for (遍历链表) {
            if (找到相同key) {
                覆盖;
                break;
            }
            if (到达末尾) {
                尾插法插入;
                // 链表长度 >= 8 且 数组长度 >= 64，转红黑树
                if (binCount >= TREEIFY_THRESHOLD - 1)
                    treeifyBin(tab, hash);
                break;
            }
        }
    }
}
```

## 如何减少碰撞

```
┌─────────────────────────────────────────────────────────────┐
│                    减少碰撞的方法                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. 好的 hashCode() 实现                                   │
│      • 均匀分布                                             │
│      • 使用所有关键字段                                     │
│                                                             │
│   2. 合适的数组大小                                         │
│      • 2的幂次方 (位运算优化)                               │
│      • 足够大减少碰撞                                       │
│                                                             │
│   3. 适当的负载因子                                         │
│      • 0.75 平衡空间和碰撞                                  │
│      • 越小碰撞越少，空间浪费越多                           │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 面试回答

### 30秒版本

> **Hash 碰撞**是不同 key 计算出相同 hash 值。解决方法：**链地址法**（HashMap 用，链表+红黑树）、**开放地址法**（ThreadLocalMap 用，线性探测找空位）、再哈希法、公共溢出区。HashMap 用**扰动函数**（高16位异或）减少碰撞，链表 ≥8 转红黑树优化查询。

### 1分钟版本

> **定义**：不同 key 产生相同 hash 值
>
> **解决方案**：
> 1. **链地址法**：HashMap 使用
>    - 同桶元素链表连接
>    - JDK8 链表≥8 转红黑树
>
> 2. **开放地址法**：ThreadLocalMap 使用
>    - 冲突时探测下一个空位
>
> **HashMap 优化**：
> - 扰动函数：高16位参与运算
> - 红黑树：O(n) → O(log n)
>
> **减少碰撞**：
> - 好的 hashCode 实现
> - 合适的数组大小和负载因子

---

*关联文档：[hashmap-principle.md](hashmap-principle.md)*
