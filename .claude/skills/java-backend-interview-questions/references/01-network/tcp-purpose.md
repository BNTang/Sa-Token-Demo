# TCP 是用来解决什么问题？

## TCP 核心目标

```
┌─────────────────────────────────────────────────────────────┐
│                    TCP 解决的核心问题                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   IP 层的问题 (不可靠)：                                     │
│   ├── 数据包可能丢失                                        │
│   ├── 数据包可能乱序到达                                    │
│   ├── 数据包可能重复                                        │
│   └── 数据包可能损坏                                        │
│                                                             │
│   TCP 的解决方案：                                           │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  在不可靠的 IP 层之上，提供可靠的字节流传输           │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   具体解决：                                                 │
│   ├── 可靠传输：确保数据不丢失、不重复、不损坏              │
│   ├── 有序传输：确保数据按发送顺序到达                       │
│   ├── 流量控制：避免接收方处理不过来                        │
│   └── 拥塞控制：避免网络过载                                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 问题一：丢包问题

```
┌─────────────────────────────────────────────────────────────┐
│                    丢包问题与解决                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   问题：IP 网络可能丢弃数据包                                │
│                                                             │
│   发送方                                 接收方              │
│      │ ──── Packet 1 ─────────────────→ │                  │
│      │ ──── Packet 2 ────────X (丢失)   │                  │
│      │ ──── Packet 3 ─────────────────→ │                  │
│      │                                   │                  │
│                                                             │
│   TCP 解决方案：确认重传机制 (ACK + 超时重传)                │
│                                                             │
│   发送方                                 接收方              │
│      │ ──── Seq=1 ─────────────────────→ │                 │
│      │ ←─── ACK=2 ──────────────────────  │                │
│      │ ──── Seq=2 ────────X (丢失)        │                │
│      │     (超时，未收到 ACK)              │                │
│      │ ──── Seq=2 (重传) ──────────────→ │                 │
│      │ ←─── ACK=3 ──────────────────────  │                │
│                                                             │
│   机制：                                                     │
│   • 序列号 (Seq)：标识每个字节                              │
│   • 确认号 (ACK)：告知收到了哪些数据                        │
│   • 超时重传：未收到 ACK 则重发                             │
│   • 快速重传：收到 3 个重复 ACK 立即重传                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 问题二：乱序问题

```
┌─────────────────────────────────────────────────────────────┐
│                    乱序问题与解决                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   问题：数据包可能走不同路径，先发后到                       │
│                                                             │
│   发送方                                 接收方              │
│      │ ──── Seq=1 ──(慢路径)───────────→ │  收到 3         │
│      │ ──── Seq=2 ──(慢路径)───────────→ │  收到 1         │
│      │ ──── Seq=3 ──(快路径)───────────→ │  收到 2         │
│      │                                   │  顺序: 3,1,2    │
│                                                             │
│   TCP 解决方案：序列号 + 重排序                              │
│                                                             │
│   接收方缓冲区:                                              │
│   ┌───┬───┬───┬───┬───┐                                   │
│   │ 1 │ 2 │ 3 │   │   │  ← 按序列号排序后交付应用层         │
│   └───┴───┴───┴───┴───┘                                   │
│                                                             │
│   机制：                                                     │
│   • 每个字节都有序列号                                      │
│   • 接收方维护接收窗口，缓存乱序数据                        │
│   • 等待缺失的数据到达后，按顺序交付应用                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 问题三：流量控制

```
┌─────────────────────────────────────────────────────────────┐
│                    流量控制                                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   问题：发送方太快，接收方处理不过来                         │
│                                                             │
│   快速发送方            缓慢接收方                           │
│      │ ───→ ───→ ───→  │ 缓冲区满！                        │
│      │ ───→ ───→       │ 数据丢失！                        │
│                                                             │
│   TCP 解决方案：滑动窗口                                     │
│                                                             │
│   接收方告知发送方自己的接收窗口大小 (rwnd)                  │
│                                                             │
│   发送方                                 接收方              │
│      │ ──── 发送数据 ───────────────→    │                 │
│      │ ←─── ACK, Window=4096 ─────────   │  还能接收4KB    │
│      │ ──── 发送数据 ───────────────→    │                 │
│      │ ←─── ACK, Window=0 ────────────   │  缓冲区满，暂停 │
│      │                                   │                 │
│      │     (等待)                         │                 │
│      │ ←─── ACK, Window=2048 ─────────   │  可以继续了     │
│                                                             │
│   机制：                                                     │
│   • 接收窗口 (rwnd)：接收方可用缓冲区大小                   │
│   • 发送方根据 rwnd 调整发送速率                            │
│   • Window=0 时，发送方暂停，定期探测                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 问题四：拥塞控制

```
┌─────────────────────────────────────────────────────────────┐
│                    拥塞控制                                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   问题：网络中传输过多数据，路由器丢包                       │
│                                                             │
│   ┌─────┐        ┌──────────┐        ┌─────┐               │
│   │ 发1 │───────→│  路由器  │←───────│ 发2 │               │
│   └─────┘        │ 队列满了 │        └─────┘               │
│                  │   丢包！ │                               │
│                  └──────────┘                               │
│                                                             │
│   TCP 解决方案：拥塞窗口 (cwnd) + 拥塞控制算法               │
│                                                             │
│   1. 慢启动 (Slow Start)                                    │
│      cwnd 从小开始，指数增长                                 │
│      cwnd: 1 → 2 → 4 → 8 → 16...                           │
│                                                             │
│   2. 拥塞避免 (Congestion Avoidance)                        │
│      达到阈值后，线性增长                                    │
│      cwnd: 16 → 17 → 18 → 19...                            │
│                                                             │
│   3. 快速恢复 (Fast Recovery)                               │
│      收到 3 个重复 ACK，cwnd 减半，进入拥塞避免              │
│                                                             │
│   ┌───────────────────────────────────────────────────────┐│
│   │cwnd                                                   ││
│   │  ^                                                    ││
│   │  │           /\                                       ││
│   │  │          /  \  快速恢复                            ││
│   │  │         /    \___________/                         ││
│   │  │        /                                           ││
│   │  │   ____/  慢启动 → 拥塞避免                          ││
│   │  └──────────────────────────────────────────→ time   ││
│   └───────────────────────────────────────────────────────┘│
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 问题五：连接管理

```
┌─────────────────────────────────────────────────────────────┐
│                    连接管理                                  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   问题：如何建立可靠连接？如何优雅关闭？                     │
│                                                             │
│   三次握手 (建立连接)：                                      │
│   ┌─────────────────────────────────────────────────────┐  │
│   │ Client              Server                          │  │
│   │   │ ─── SYN ────────────→ │  客户端想建立连接       │  │
│   │   │ ←── SYN+ACK ───────── │  服务端同意并确认       │  │
│   │   │ ─── ACK ────────────→ │  客户端确认             │  │
│   │   │      连接建立完成      │                         │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   为什么需要三次？                                           │
│   • 防止历史连接：旧的 SYN 被误认为新连接                   │
│   • 双方同步序列号：确保双方都收到对方的初始序列号          │
│                                                             │
│   四次挥手 (关闭连接)：                                      │
│   ┌─────────────────────────────────────────────────────┐  │
│   │ Client              Server                          │  │
│   │   │ ─── FIN ────────────→ │  客户端要关闭          │  │
│   │   │ ←── ACK ────────────── │  服务端确认           │  │
│   │   │ ←── FIN ────────────── │  服务端也要关闭       │  │
│   │   │ ─── ACK ────────────→ │  客户端确认           │  │
│   │   │      连接关闭完成      │                        │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   为什么需要四次？                                           │
│   • TCP 全双工：两个方向需要分别关闭                        │
│   • 服务端可能还有数据要发送，ACK 和 FIN 分开发             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## TCP vs UDP

```
┌─────────────────────────────────────────────────────────────┐
│                    TCP vs UDP                                │
├─────────────────────┬───────────────────────────────────────┤
│       特性          │      TCP           │      UDP         │
├─────────────────────┼───────────────────┼──────────────────┤
│   连接             │   面向连接         │   无连接         │
│   可靠性           │   可靠传输         │   不可靠         │
│   有序性           │   保证顺序         │   不保证         │
│   流量控制         │   有               │   无             │
│   拥塞控制         │   有               │   无             │
│   传输效率         │   较低             │   高             │
│   头部开销         │   20字节           │   8字节          │
│   典型场景         │   HTTP/HTTPS       │   DNS/视频直播   │
├─────────────────────┴───────────────────┴──────────────────┤
│                                                             │
│   TCP 适用：需要可靠传输的场景（网页、文件传输、邮件）       │
│   UDP 适用：实时性优先的场景（直播、游戏、DNS查询）          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 面试回答

### 30秒版本

> TCP 解决的核心问题是：**在不可靠的 IP 网络上提供可靠的字节流传输**。具体解决：1）丢包 → **确认重传**；2）乱序 → **序列号重排序**；3）接收方处理慢 → **流量控制（滑动窗口）**；4）网络拥塞 → **拥塞控制（慢启动、拥塞避免）**；5）连接管理 → **三次握手、四次挥手**。

### 1分钟版本

> **TCP 解决的问题**：
>
> 1. **可靠传输**（解决丢包）
>    - 序列号 + 确认号（ACK）
>    - 超时重传 + 快速重传
>
> 2. **有序传输**（解决乱序）
>    - 接收方按序列号重排序
>    - 缓存乱序数据，等待缺失部分
>
> 3. **流量控制**（解决接收方处理慢）
>    - 滑动窗口机制
>    - 接收方通告可用窗口大小（rwnd）
>
> 4. **拥塞控制**（解决网络拥塞）
>    - 慢启动：指数增长探测带宽
>    - 拥塞避免：线性增长
>    - 快速恢复：丢包后减半窗口
>
> 5. **连接管理**
>    - 三次握手建立连接（同步序列号）
>    - 四次挥手关闭连接（全双工分别关闭）

---

*关联文档：[tcp-connection.md](tcp-connection.md) | [http-versions.md](http-versions.md)*
