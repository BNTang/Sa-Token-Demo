# 到底什么是 TCP 连接

> 分类: 网络协议 | 难度: ⭐⭐⭐ | 频率: 高频

---

## 一、TCP 连接的本质

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          TCP 连接的本质                                           │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  TCP 连接不是物理连接，而是一种 "状态" 的约定:                                    │
│                                                                                  │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │                                                                            │ │
│  │   TCP 连接 = 一对 Socket + 序列号 + 窗口大小                               │ │
│  │                                                                            │ │
│  │   ┌─────────────────────────────────────────────────────────────────────┐ │ │
│  │   │  四元组: (源IP, 源端口, 目的IP, 目的端口)                            │ │ │
│  │   │                                                                      │ │ │
│  │   │  客户端维护:                          服务端维护:                    │ │ │
│  │   │  • 发送序列号 (Seq)                   • 发送序列号 (Seq)             │ │ │
│  │   │  • 确认序列号 (Ack)                   • 确认序列号 (Ack)             │ │ │
│  │   │  • 发送窗口                           • 发送窗口                     │ │ │
│  │   │  • 接收窗口                           • 接收窗口                     │ │ │
│  │   │  • 连接状态                           • 连接状态                     │ │ │
│  │   └─────────────────────────────────────────────────────────────────────┘ │ │
│  │                                                                            │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
│  通俗理解: TCP 连接就是双方在内存中各自维护的一组状态信息                         │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 二、三次握手建立连接

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          三次握手                                                 │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   客户端                                                    服务端               │
│   (CLOSED)                                                 (LISTEN)             │
│       │                                                        │                │
│       │  ─────────── SYN, Seq=x ──────────────────→           │                │
│       │  第1次握手: 我要建立连接                               │                │
│   (SYN_SENT)                                                   │                │
│       │                                                        │                │
│       │  ←────────── SYN+ACK, Seq=y, Ack=x+1 ─────            │                │
│       │  第2次握手: 同意，我也要建立连接                   (SYN_RCVD)           │
│       │                                                        │                │
│       │  ─────────── ACK, Seq=x+1, Ack=y+1 ───────→           │                │
│       │  第3次握手: 好的，确认                                 │                │
│  (ESTABLISHED)                                           (ESTABLISHED)          │
│       │                                                        │                │
│       │  ←─────────── 数据传输 ───────────────→               │                │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘

为什么是三次握手?
┌──────────────────────────────────────────────────────────────────────────────────┐
│  1. 确认双方的发送和接收能力都正常                                               │
│     • 第1次: 服务端确认 "客户端能发"                                             │
│     • 第2次: 客户端确认 "服务端能收能发"                                         │
│     • 第3次: 服务端确认 "客户端能收"                                             │
│                                                                                  │
│  2. 同步初始序列号 (ISN)                                                         │
│     • 双方交换各自的初始序列号，为后续数据传输做准备                             │
│                                                                                  │
│  3. 防止历史连接的干扰                                                           │
│     • 旧的 SYN 请求到达，客户端可以通过第三次握手拒绝                            │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 三、四次挥手断开连接

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          四次挥手                                                 │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   客户端                                                    服务端               │
│  (ESTABLISHED)                                            (ESTABLISHED)          │
│       │                                                        │                │
│       │  ─────────── FIN, Seq=u ──────────────────→           │                │
│       │  第1次挥手: 我要断开连接                               │                │
│   (FIN_WAIT_1)                                                 │                │
│       │                                                        │                │
│       │  ←────────── ACK, Ack=u+1 ────────────────            │                │
│       │  第2次挥手: 好的，收到了                           (CLOSE_WAIT)         │
│   (FIN_WAIT_2)                                                 │                │
│       │                                                        │                │
│       │                     (服务端可能还有数据要发送)          │                │
│       │                                                        │                │
│       │  ←────────── FIN, Seq=v ─────────────────             │                │
│       │  第3次挥手: 我也要断开连接                         (LAST_ACK)           │
│   (TIME_WAIT)                                                  │                │
│       │                                                        │                │
│       │  ─────────── ACK, Ack=v+1 ────────────────→           │                │
│       │  第4次挥手: 好的，确认                                 │                │
│       │                                                    (CLOSED)             │
│       │                                                        │                │
│       │  ←─── 等待 2MSL ───→                                  │                │
│   (CLOSED)                                                     │                │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘

为什么是四次挥手?
• TCP 是全双工，两个方向需要分别关闭
• 收到 FIN 只表示对方不再发送数据，但自己可能还有数据要发
```

---

## 四、连接的内核数据结构

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                      Linux 内核中的 TCP 连接                                      │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│   struct socket {                     // Socket 结构                             │
│       struct sock *sk;                // 指向传输控制块                          │
│       ...                                                                        │
│   };                                                                             │
│                                                                                  │
│   struct tcp_sock {                   // TCP 控制块                              │
│       // 序列号相关                                                              │
│       u32 snd_una;                    // 发送未确认的起始序列号                  │
│       u32 snd_nxt;                    // 下一个要发送的序列号                    │
│       u32 rcv_nxt;                    // 下一个期望接收的序列号                  │
│                                                                                  │
│       // 窗口相关                                                                │
│       u32 snd_wnd;                    // 发送窗口大小                            │
│       u32 rcv_wnd;                    // 接收窗口大小                            │
│                                                                                  │
│       // 缓冲区                                                                  │
│       struct sk_buff_head receive_queue;   // 接收队列                           │
│       struct sk_buff_head write_queue;     // 发送队列                           │
│                                                                                  │
│       // 状态                                                                    │
│       int state;                      // 连接状态 (ESTABLISHED等)                │
│       ...                                                                        │
│   };                                                                             │
│                                                                                  │
│   每个连接大约占用 3-4KB 内存                                                    │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 五、Java 中的 TCP 连接

```java
/**
 * TCP 服务端
 */
public class TCPServer {
    public static void main(String[] args) throws IOException {
        // 创建 ServerSocket，进入 LISTEN 状态
        ServerSocket serverSocket = new ServerSocket(8080);
        System.out.println("服务端监听端口 8080...");
        
        while (true) {
            // accept() 阻塞等待连接
            // 三次握手在这里完成，返回 ESTABLISHED 状态的连接
            Socket clientSocket = serverSocket.accept();
            
            // 获取连接信息 (四元组)
            System.out.println("客户端连接: " + 
                clientSocket.getInetAddress() + ":" + clientSocket.getPort());
            
            // 处理连接...
            handleConnection(clientSocket);
        }
    }
}

/**
 * TCP 客户端
 */
public class TCPClient {
    public static void main(String[] args) throws IOException {
        // 创建 Socket，触发三次握手
        Socket socket = new Socket("127.0.0.1", 8080);
        // 到这里连接已经建立 (ESTABLISHED)
        
        // 发送数据
        OutputStream out = socket.getOutputStream();
        out.write("Hello Server".getBytes());
        
        // 关闭连接，触发四次挥手
        socket.close();
    }
}
```

---

## 六、面试回答

### 30秒版本

> TCP 连接不是物理连接，而是**双方维护的一组状态信息**，包括：
> - **四元组**：源IP、源端口、目的IP、目的端口（唯一标识连接）
> - **序列号**：用于保证数据有序和可靠
> - **窗口大小**：用于流量控制
> - **连接状态**：如 ESTABLISHED、TIME_WAIT 等
>
> 建立连接需要三次握手（同步序列号、确认双方收发能力），断开需要四次挥手（双工通信需分别关闭）。

### 1分钟版本

> **TCP 连接的本质**：
> 是一种逻辑上的概念，实际是通信双方在内存中各自维护的状态信息。通过四元组（源IP、源端口、目的IP、目的端口）唯一标识。
>
> **连接包含的信息**：
> - 序列号（Seq）：保证数据按序到达
> - 确认号（Ack）：确认收到的数据
> - 窗口大小：流量控制
> - 连接状态：LISTEN、ESTABLISHED、TIME_WAIT 等
>
> **三次握手目的**：
> 1. 确认双方的发送和接收能力
> 2. 同步初始序列号
> 3. 防止历史连接干扰
>
> **四次挥手原因**：
> TCP 是全双工，两个方向需要分别关闭。收到 FIN 只表示对方不再发送，自己可能还有数据要发。
>
> **内核实现**：
> 每个连接对应一个 `tcp_sock` 结构，包含发送/接收队列、序列号、窗口等，大约占用 3-4KB 内存。
