# 在什么情况下，不推荐为数据库建立索引？

## 不建索引的场景

```
┌─────────────────────────────────────────────────────────────┐
│                    不推荐建索引的情况                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   1. 数据量小的表                                            │
│   2. 选择性低的列                                            │
│   3. 频繁更新的表/列                                         │
│   4. 查询很少用到的列                                        │
│   5. 大字段 (TEXT, BLOB)                                    │
│   6. 写多读少的表                                            │
│   7. 数据重复率高的列                                        │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 详细说明

### 1. 数据量小的表

```
┌─────────────────────────────────────────────────────────────┐
│                    数据量小的表                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   场景:                                                      │
│   • 配置表 (几十行)                                         │
│   • 字典表 (几百行)                                         │
│   • 静态数据表                                              │
│                                                             │
│   原因:                                                      │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  1. 全表扫描可能比走索引更快                         │  │
│   │  2. 数据量小，MySQL 可能直接放内存                   │  │
│   │  3. 索引增加存储开销                                 │  │
│   │  4. 维护索引有额外成本                               │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   经验值:                                                    │
│   • 几百行以下的表，通常不需要额外索引                      │
│   • 主键索引足够                                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 2. 选择性低的列

```
┌─────────────────────────────────────────────────────────────┐
│                    选择性低的列                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   选择性计算:                                                │
│   选择性 = COUNT(DISTINCT column) / COUNT(*)                │
│                                                             │
│   示例:                                                      │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  列名       不同值数量    总行数    选择性           │  │
│   │  ────────────────────────────────────────────────   │  │
│   │  gender     2            100万     0.000002 (极低)  │  │
│   │  status     5            100万     0.000005 (极低)  │  │
│   │  is_deleted 2            100万     0.000002 (极低)  │  │
│   │  email      100万        100万     1.0 (最高)       │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   为什么不建:                                                │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  • 索引扫描后还要大量回表                            │  │
│   │  • 可能比全表扫描更慢                                │  │
│   │  • MySQL 优化器可能直接放弃索引                      │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   例外: 数据分布极不均匀时可以考虑                          │
│   如 status=0 有 99%，status=1 只有 1%                      │
│   查 status=1 时索引有效                                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 3. 频繁更新的表/列

```
┌─────────────────────────────────────────────────────────────┐
│                    频繁更新的列                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   原因:                                                      │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  每次 INSERT/UPDATE/DELETE 都要维护索引              │  │
│   │  • 更新索引树结构                                    │  │
│   │  • 可能导致页分裂                                    │  │
│   │  • 增加 I/O 操作                                     │  │
│   │  • 影响写入性能                                      │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   典型场景:                                                  │
│   • 日志表 (只写不读或很少读)                               │
│   • 统计表 (频繁 update)                                    │
│   • 消息队列表 (高频写入)                                   │
│                                                             │
│   权衡:                                                      │
│   • 写多读少 → 少建索引                                     │
│   • 读多写少 → 可以多建索引                                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 4. 大字段 (TEXT, BLOB)

```
┌─────────────────────────────────────────────────────────────┐
│                    大字段                                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   问题:                                                      │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  • 索引占用空间巨大                                  │  │
│   │  • 索引维护成本高                                    │  │
│   │  • B+ 树效率下降                                     │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   替代方案:                                                  │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  1. 前缀索引                                         │  │
│   │     CREATE INDEX idx_content ON article(content(50));│  │
│   │                                                     │  │
│   │  2. 全文索引                                         │  │
│   │     CREATE FULLTEXT INDEX idx_ft ON article(content);│  │
│   │                                                     │  │
│   │  3. 使用 Elasticsearch 等搜索引擎                    │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 5. 查询很少用到的列

```
┌─────────────────────────────────────────────────────────────┐
│                    查询很少用到的列                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   原因:                                                      │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  • 索引占用磁盘空间                                  │  │
│   │  • 每次写操作都要维护                                │  │
│   │  • 增加备份时间                                      │  │
│   │  • 浪费资源                                          │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   例如:                                                      │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  remark 备注字段                                     │  │
│   │  description 描述字段                                │  │
│   │  很少用于 WHERE 条件                                 │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 6. 有大量重复值的列

```
┌─────────────────────────────────────────────────────────────┐
│                    大量重复值                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   示例:                                                      │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  is_deleted: 只有 0 和 1                             │  │
│   │  type: 只有几个固定值                                │  │
│   │  priority: 1-5 几个级别                              │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
│   问题:                                                      │
│   ┌─────────────────────────────────────────────────────┐  │
│   │  WHERE is_deleted = 0                                │  │
│   │  -- 假设 90% 的数据 is_deleted = 0                   │  │
│   │  -- 索引扫描后要回表 90% 的数据                      │  │
│   │  -- 不如直接全表扫描                                 │  │
│   └─────────────────────────────────────────────────────┘  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 索引开销总结

```
┌─────────────────────────────────────────────────────────────┐
│                    索引的开销                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   空间开销:                                                  │
│   • 索引需要额外存储空间                                    │
│   • 可能占到表大小的 30%-50%                                │
│                                                             │
│   时间开销:                                                  │
│   • INSERT: 需要维护所有索引                                │
│   • UPDATE: 如果更新索引列，需要维护索引                    │
│   • DELETE: 需要更新所有索引                                │
│                                                             │
│   维护开销:                                                  │
│   • 索引碎片整理                                            │
│   • 备份时间增加                                            │
│   • 优化器分析成本                                          │
│                                                             │
│   建议:                                                      │
│   • 单表索引不超过 5 个                                     │
│   • 联合索引字段不超过 5 个                                 │
│   • 定期检查无用索引并删除                                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

## 面试回答

### 30秒版本

> 不建索引的情况：1）**数据量小**：几百行的配置表，全表扫描更快；2）**选择性低**：性别、状态等只有几个值的列；3）**频繁更新**：每次写操作都要维护索引；4）**大字段**：TEXT/BLOB 占用空间大，考虑前缀索引或全文索引；5）**很少查询**的列；6）**写多读少**的表。核心原则：索引有维护开销，要权衡读写比例。

### 1分钟版本

> **不建索引的场景**：
>
> 1. **数据量小的表**
>    - 几百行的配置表、字典表
>    - 全表扫描比走索引快
>
> 2. **选择性低的列**
>    - 性别、状态、布尔值
>    - 选择性 = 不同值/总行数
>    - 选择性太低，优化器会放弃索引
>
> 3. **频繁更新的列**
>    - 每次写操作都要维护索引
>    - 日志表、统计表
>
> 4. **大字段 (TEXT/BLOB)**
>    - 索引太大
>    - 用前缀索引或全文索引代替
>
> 5. **很少用于查询的列**
>    - 纯粹浪费资源
>
> 6. **写多读少的表**
>    - 权衡读写比例
>
> **建议**：单表索引不超过 5 个

---

*关联文档：[mysql-index-tips.md](mysql-index-tips.md) | [mysql-index-types.md](mysql-index-types.md)*
