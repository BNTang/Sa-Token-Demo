# Spring IOC 详解

> 分类: Spring | 难度: ⭐⭐⭐ | 频率: 高频

---

## 一、什么是 IOC

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          IOC 控制反转                                             │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  IOC (Inversion of Control) 控制反转:                                            │
│  将对象的创建和依赖关系的管理从代码中转移到外部容器                               │
│                                                                                  │
│  传统方式 (控制正转):                                                            │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │  class UserService {                                                        │ │
│  │      private UserDao userDao = new UserDaoImpl();  // 自己创建依赖          │ │
│  │  }                                                                          │ │
│  │                                                                             │ │
│  │  问题:                                                                      │ │
│  │  • 强耦合: UserService 依赖具体实现 UserDaoImpl                             │ │
│  │  • 难测试: 无法 mock UserDao                                                │ │
│  │  • 难扩展: 更换实现需要修改代码                                             │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
│  IOC 方式 (控制反转):                                                            │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │  class UserService {                                                        │ │
│  │      private UserDao userDao;  // 由容器注入                                │ │
│  │                                                                             │ │
│  │      public UserService(UserDao userDao) {                                  │ │
│  │          this.userDao = userDao;  // 依赖从外部传入                         │ │
│  │      }                                                                      │ │
│  │  }                                                                          │ │
│  │                                                                             │ │
│  │  优点:                                                                      │ │
│  │  • 松耦合: 依赖接口，不依赖实现                                             │ │
│  │  • 易测试: 可以注入 mock 对象                                               │ │
│  │  • 易扩展: 更换实现只需修改配置                                             │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
│  控制反转: "控制" 指创建对象的权力，"反转" 指从代码转移到容器                    │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 二、IOC 和 DI 的关系

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          IOC vs DI                                                │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  IOC (Inversion of Control) - 控制反转                                           │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │  设计思想/原则                                                              │ │
│  │  对象的创建和管理由代码转移到容器                                           │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                            ↓ 实现方式                                            │
│  DI (Dependency Injection) - 依赖注入                                            │
│  ┌────────────────────────────────────────────────────────────────────────────┐ │
│  │  IOC 的具体实现技术                                                         │ │
│  │  容器在创建对象时，自动注入其依赖的对象                                     │ │
│  └────────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
│  IOC 是目标 (What)，DI 是实现手段 (How)                                          │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 三、依赖注入的三种方式

```java
/**
 * 1. 构造器注入 (推荐)
 */
@Service
public class UserService {
    
    private final UserDao userDao;
    private final OrderDao orderDao;
    
    @Autowired  // Spring 4.3+ 单构造器可省略
    public UserService(UserDao userDao, OrderDao orderDao) {
        this.userDao = userDao;
        this.orderDao = orderDao;
    }
}

// 优点: 依赖不可变(final)，保证对象完整性，便于测试

/**
 * 2. Setter 注入
 */
@Service
public class UserService {
    
    private UserDao userDao;
    
    @Autowired
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
}

// 优点: 可选依赖，允许后期修改
// 缺点: 对象可能处于不完整状态

/**
 * 3. 字段注入 (不推荐)
 */
@Service
public class UserService {
    
    @Autowired
    private UserDao userDao;  // 直接注入到字段
}

// 缺点: 
// • 无法声明为 final
// • 难以进行单元测试
// • 隐藏依赖关系
```

---

## 四、IOC 容器的工作原理

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          IOC 容器工作流程                                         │
├──────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  1. 扫描配置 (XML/注解/JavaConfig)                                               │
│     ┌─────────────────────────────────────────────────────────────────────────┐ │
│     │  @ComponentScan("com.example")                                          │ │
│     │  扫描 @Component, @Service, @Repository, @Controller                    │ │
│     └─────────────────────────────────────────────────────────────────────────┘ │
│                              ↓                                                   │
│  2. 生成 BeanDefinition                                                          │
│     ┌─────────────────────────────────────────────────────────────────────────┐ │
│     │  Bean 的元数据: 类名、作用域、依赖、初始化方法等                         │ │
│     │  存储在 BeanDefinitionRegistry 中                                        │ │
│     └─────────────────────────────────────────────────────────────────────────┘ │
│                              ↓                                                   │
│  3. 实例化 Bean                                                                  │
│     ┌─────────────────────────────────────────────────────────────────────────┐ │
│     │  通过反射创建对象实例                                                    │ │
│     │  此时对象属性为空                                                        │ │
│     └─────────────────────────────────────────────────────────────────────────┘ │
│                              ↓                                                   │
│  4. 属性填充 (依赖注入)                                                          │
│     ┌─────────────────────────────────────────────────────────────────────────┐ │
│     │  根据 @Autowired 等注解，注入依赖对象                                    │ │
│     │  处理循环依赖 (三级缓存)                                                 │ │
│     └─────────────────────────────────────────────────────────────────────────┘ │
│                              ↓                                                   │
│  5. 初始化                                                                       │
│     ┌─────────────────────────────────────────────────────────────────────────┐ │
│     │  调用 @PostConstruct、InitializingBean.afterPropertiesSet()             │ │
│     │  执行 BeanPostProcessor 后置处理                                         │ │
│     └─────────────────────────────────────────────────────────────────────────┘ │
│                              ↓                                                   │
│  6. 放入容器                                                                     │
│     ┌─────────────────────────────────────────────────────────────────────────┐ │
│     │  单例 Bean 放入 singletonObjects 缓存                                    │ │
│     │  后续获取直接从缓存返回                                                  │ │
│     └─────────────────────────────────────────────────────────────────────────┘ │
│                                                                                  │
└──────────────────────────────────────────────────────────────────────────────────┘
```

---

## 五、Bean 的作用域

```
┌──────────────────────────────────────────────────────────────────────────────────┐
│                          Bean 作用域                                              │
├─────────────────┬────────────────────────────────────────────────────────────────┤
│  singleton      │  默认，整个容器只有一个实例                                     │
│  prototype      │  每次获取创建新实例                                             │
│  request        │  每个 HTTP 请求一个实例 (Web)                                   │
│  session        │  每个 Session 一个实例 (Web)                                    │
│  application    │  每个 ServletContext 一个实例 (Web)                             │
└─────────────────┴────────────────────────────────────────────────────────────────┘
```

```java
@Service
@Scope("prototype")  // 指定作用域
public class PrototypeBean {
    // 每次获取都是新实例
}

@Service
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestScopedBean {
    // 每个请求一个实例
}
```

---

## 六、面试回答

### 30秒版本

> **IOC（控制反转）** 是一种设计思想，将对象的创建和依赖管理从代码中转移到外部容器。
>
> **DI（依赖注入）** 是 IOC 的实现方式，容器在创建对象时自动注入其依赖。
>
> **好处**：
> - 松耦合：依赖接口，不依赖实现
> - 易测试：可以注入 mock 对象
> - 易扩展：更换实现只需修改配置
>
> 推荐使用**构造器注入**，依赖不可变且便于测试。

### 1分钟版本

> **IOC 是什么**：
> 控制反转，一种设计思想。传统方式中对象自己创建依赖（new UserDaoImpl()），IOC 方式中对象的创建和依赖关系由容器管理。
>
> **DI 是什么**：
> 依赖注入，是 IOC 的具体实现。容器在创建对象时，自动将其依赖的对象注入进去。
>
> **三种注入方式**：
> 1. 构造器注入（推荐）：依赖不可变，对象完整
> 2. Setter 注入：可选依赖
> 3. 字段注入（不推荐）：难以测试
>
> **IOC 容器工作流程**：
> 1. 扫描注解/配置
> 2. 生成 BeanDefinition
> 3. 反射实例化 Bean
> 4. 属性填充（依赖注入）
> 5. 初始化（@PostConstruct）
> 6. 放入单例缓存
>
> **好处**：
> - 解耦：代码只依赖接口
> - 可测试：可以注入 mock
> - 可扩展：更换实现改配置即可
