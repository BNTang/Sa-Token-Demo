# Java 内存模型（JMM）规范

> Java 并发编程规范 - 内存模型、原子性、可见性、有序性、happens-before

---

## 1. Java 内存模型（JMM）

### 1.1 核心语义

| 要素 | 说明 |
|------|------|
| **是什么** | 定义线程与主内存之间交互的规范 |
| **不是什么** | 不是 JVM 内存结构（堆、栈、方法区） |
| **解决什么** | 多线程环境下变量的可见性、有序性问题 |
| **一句话** | 规定了什么操作能看到什么结果 |

### 1.2 系统行为（内存交互模型）

```
┌────────────────┐          ┌────────────────┐
│    Thread 1    │          │    Thread 2    │
│  ┌──────────┐  │          │  ┌──────────┐  │
│  │ 工作内存 │  │          │  │ 工作内存 │  │
│  │ (本地副本)│  │          │  │ (本地副本)│  │
│  └────┬─────┘  │          │  └────┬─────┘  │
└───────┼────────┘          └───────┼────────┘
        │ read/load                 │ read/load
        │ store/write               │ store/write
        ▼                           ▼
┌─────────────────────────────────────────────┐
│                  主内存                      │
│           (所有共享变量)                     │
└─────────────────────────────────────────────┘
```

### 1.3 八种原子操作

| 操作 | 作用域 | 说明 |
|------|--------|------|
| lock | 主内存 | 锁定变量，标识为线程独占 |
| unlock | 主内存 | 解锁变量，允许其他线程锁定 |
| read | 主内存 | 读取变量值到工作内存 |
| load | 工作内存 | 将 read 的值放入工作内存副本 |
| use | 工作内存 | 将值传递给执行引擎 |
| assign | 工作内存 | 将执行结果赋值给工作内存变量 |
| store | 工作内存 | 将值传输到主内存 |
| write | 主内存 | 将 store 的值写入主内存变量 |

### 1.4 风险场景

| 问题 | 原因 | 后果 |
|------|------|------|
| 可见性问题 | 线程 A 修改后未同步到主内存，线程 B 读到旧值 | 数据不一致 |
| 有序性问题 | 指令重排导致操作顺序变化 | 逻辑错误 |
| 原子性问题 | 复合操作被打断 | 中间状态泄漏 |

---

## 2. 原子性、可见性、有序性

### 2.1 原子性（Atomicity）

| 要素 | 说明 |
|------|------|
| **是什么** | 操作不可分割，要么全部完成，要么全部不执行 |
| **典型反例** | `i++`（读取 → 加 1 → 写回，三步可被打断） |
| **一句话** | 一步到位，不存在中间状态 |

**保证原子性的手段**：

| 手段 | 适用场景 |
|------|---------|
| synchronized | 临界区保护 |
| Lock | 临界区保护 |
| Atomic 类 | 单变量原子操作（CAS） |

### 2.2 可见性（Visibility）

| 要素 | 说明 |
|------|------|
| **是什么** | 一个线程的修改对其他线程立即可见 |
| **典型反例** | 循环中检测 flag，其他线程改了 flag 但循环不停 |
| **一句话** | 你改了，我立刻能看到 |

**保证可见性的手段**：

| 手段 | 原理 |
|------|------|
| volatile | 写立即刷新到主内存，读从主内存取 |
| synchronized | 解锁前刷新，加锁后重新读取 |
| final | 构造完成后对其他线程可见 |

### 2.3 有序性（Ordering）

| 要素 | 说明 |
|------|------|
| **是什么** | 程序按照代码顺序执行 |
| **典型反例** | 双重检查锁定单例，未用 volatile 可能返回未初始化对象 |
| **一句话** | 写在前面的先执行 |

**保证有序性的手段**：

| 手段 | 原理 |
|------|------|
| volatile | 禁止重排序 |
| synchronized | happens-before 规则 |
| happens-before 规则 | JMM 定义的顺序保证 |

### 2.4 三者关系总结

| 特性 | volatile | synchronized | Lock | Atomic |
|------|----------|--------------|------|--------|
| 原子性 | ❌ 单读写原子，复合不原子 | ✅ | ✅ | ✅ 单变量 |
| 可见性 | ✅ | ✅ | ✅ | ✅ |
| 有序性 | ✅ | ✅ | ✅ | ❌ |

---

## 3. 指令重排序

### 3.1 核心语义

| 要素 | 说明 |
|------|------|
| **是什么** | 编译器/处理器为优化性能，改变指令执行顺序 |
| **为什么** | 提高流水线效率、减少等待 |
| **风险** | 多线程环境下可能导致逻辑错误 |

### 3.2 三种重排序

| 类型 | 执行者 | 示例 |
|------|--------|------|
| 编译器重排序 | javac、JIT | 将无依赖的操作重新排列 |
| 指令级重排序 | CPU | 乱序执行（Out-of-Order） |
| 内存系统重排序 | CPU 缓存 | 读写缓冲区导致顺序变化 |

### 3.3 as-if-serial 语义

| 规则 | 说明 |
|------|------|
| 单线程保证 | 无论如何重排，单线程执行结果不变 |
| 数据依赖 | 有依赖的操作不会重排（a = 1; b = a; 不会重排） |
| 多线程风险 | 单线程正确不代表多线程正确 |

### 3.4 禁止重排序的手段

| 手段 | 原理 |
|------|------|
| volatile | 插入内存屏障 |
| synchronized | 加锁/解锁时的内存屏障 |
| final | 构造函数中的 StoreStore 屏障 |

---

## 4. happens-before 规则

### 4.1 核心语义

| 要素 | 说明 |
|------|------|
| **是什么** | JMM 定义的偏序关系，保证操作的可见性 |
| **含义** | 如果 A happens-before B，则 A 的结果对 B 可见 |
| **不是什么** | 不是时间上的先后（可以重排，只要结果一致） |

### 4.2 八大规则

| # | 规则名称 | 说明 |
|---|---------|------|
| 1 | **程序顺序规则** | 同一线程中，前面的操作 happens-before 后面的操作 |
| 2 | **监视器锁规则** | unlock 操作 happens-before 后续对同一个锁的 lock |
| 3 | **volatile 规则** | volatile 写 happens-before 后续对该变量的读 |
| 4 | **线程启动规则** | Thread.start() happens-before 该线程的任何操作 |
| 5 | **线程终止规则** | 线程的所有操作 happens-before 其他线程从 join() 返回 |
| 6 | **线程中断规则** | interrupt() 调用 happens-before 被中断线程检测到中断 |
| 7 | **对象终结规则** | 构造函数执行完成 happens-before finalize() 开始 |
| 8 | **传递性** | A happens-before B，B happens-before C → A happens-before C |

### 4.3 应用示例

```java
// 规则 3：volatile 规则
volatile boolean ready = false;
int value = 0;

// 线程 1
value = 42;        // (1)
ready = true;      // (2) volatile 写

// 线程 2
if (ready) {       // (3) volatile 读
    // value 一定是 42，因为 (1) happens-before (2)，(2) happens-before (3)
    System.out.println(value);  // (4)
}
```

### 4.4 决策规则

| 场景 | 建议 |
|------|------|
| 需要保证写对读可见 | 利用 happens-before 规则建立关系 |
| 不确定是否有 happens-before 关系 | 默认不可见，必须显式同步 |

---

## 5. final 与可见性

### 5.1 核心语义

| 要素 | 说明 |
|------|------|
| **是什么** | final 字段在构造函数完成后对其他线程可见 |
| **前提** | this 引用不能在构造函数中逸出 |
| **一句话** | 构造完成后，final 字段可安全发布 |

### 5.2 JMM 对 final 的保证

| 保证 | 说明 |
|------|------|
| 写保证 | 构造函数内对 final 字段的写入，在构造函数完成前不会被重排到构造函数外 |
| 读保证 | 首次读取 final 字段，会先读取该字段所属对象的引用 |

### 5.3 this 逸出问题

```java
// ❌ 危险：this 在构造函数中逸出
public class ThisEscape {
    private final int value;
    
    public ThisEscape() {
        // 在 value 赋值前，this 已经逸出
        EventSource.register(this);  // ❌ 其他线程可能看到未初始化的 value
        value = 42;
    }
}

// ✅ 正确：使用工厂方法
public class SafeConstruction {
    private final int value;
    
    private SafeConstruction() {
        value = 42;
    }
    
    public static SafeConstruction create() {
        SafeConstruction instance = new SafeConstruction();
        EventSource.register(instance);  // 构造完成后再发布
        return instance;
    }
}
```

---

## 6. 记忆锚点

| 概念 | 记忆句（≤20字） |
|------|----------------|
| JMM | 规定线程与主内存怎么交互 |
| 原子性 | 一步到位，没有中间状态 |
| 可见性 | 你改了，我立刻能看到 |
| 有序性 | 写在前面的先执行 |
| 指令重排 | 优化性能，但多线程可能出错 |
| happens-before | A 的结果对 B 可见的保证 |
| final 可见性 | 构造完成后可见，别让 this 逃逸 |
