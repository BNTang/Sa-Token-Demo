# 锁机制规范

> Java 并发编程规范 - 锁的原理、选择与使用

---

## 1. synchronized

### 1.1 核心语义

| 要素 | 说明 |
|------|------|
| **是什么** | JVM 内置的互斥锁，基于 Monitor（管程）实现 |
| **不是什么** | 不是可中断的、不是可超时的、不是可选择公平的 |
| **一句话** | 自动管理的互斥锁，进 monitorenter、出 monitorexit |

### 1.2 系统行为（锁升级）

```
无锁 → 偏向锁 → 轻量级锁 → 重量级锁
      (单线程)  (CAS竞争)   (阻塞等待)
```

| 锁状态 | Mark Word 存储 | 触发条件 | 性能 |
|--------|---------------|---------|------|
| 偏向锁 | 线程 ID | 单线程反复访问 | 最优 |
| 轻量级锁 | 栈中锁记录指针 | 交替执行、无实际竞争 | 优 |
| 重量级锁 | Monitor 指针 | 真正的多线程竞争 | 差 |

### 1.3 决策规则

| 条件 | 建议 | 强度 |
|------|------|------|
| 简单同步、无需高级特性 | 用 synchronized | ✅ 推荐 |
| 需要可中断、超时、公平 | 用 ReentrantLock | ✅ 必须 |
| JDK 6+ 环境 | 两者性能接近，优先 synchronized | ✅ 推荐 |

### 1.4 静态方法 vs 实例方法

| 修饰对象 | 锁对象 | 互斥范围 |
|---------|--------|---------|
| 静态方法 | Class 对象 | 所有线程、所有实例 |
| 实例方法 | this 实例 | 同一实例的线程 |

**决策规则**：
- 需要全局互斥 → 锁静态方法或 Class 对象
- 只需实例级互斥 → 锁实例方法或 this

### 1.5 指令重排与 synchronized

| 问题 | 答案 |
|------|------|
| 能禁止指令重排吗？ | 部分能。同步块内外的操作不会重排；块内可能重排但结果对外不可见 |
| 原理 | 进入时有 LoadLoad + LoadStore 屏障；退出时有 StoreStore + StoreLoad 屏障 |

### 1.6 锁降级问题

| 问题 | 答案 |
|------|------|
| 升级为重量级锁后还能降级吗？ | **不能**。锁升级是单向的 |
| 为什么？ | 避免升级/降级的性能抖动 |
| 释放后仍是重量级锁吗？ | **是**。即使所有线程释放，锁状态不变 |

---

## 2. ReentrantLock

### 2.1 核心语义

| 要素 | 说明 |
|------|------|
| **是什么** | 基于 AQS 的可重入互斥锁，提供高级特性 |
| **不是什么** | 不会自动释放，必须手动 unlock |
| **一句话** | 功能更强的显式锁，需手动管理生命周期 |

### 2.2 系统行为

```
┌─────────────────────────────────────────┐
│           AbstractQueuedSynchronizer    │
├─────────────────────────────────────────┤
│ volatile int state  (0=无锁, >0=锁定)   │
│ Thread exclusiveOwnerThread (持锁线程)  │
│ CLH 队列 (等待线程双向链表)              │
└─────────────────────────────────────────┘
```

**加锁流程**：
1. CAS 尝试将 state 从 0 改为 1
2. 成功 → 设置 exclusiveOwnerThread 为当前线程
3. 失败 → 进入 CLH 队列等待（公平锁）或再次尝试（非公平锁）

**可重入实现**：
- 同一线程再次获取 → state++
- 释放时 → state--，直到 state=0 才真正释放

### 2.3 公平锁 vs 非公平锁

| 类型 | 行为 | 性能 | 场景 |
|------|------|------|------|
| 非公平锁（默认） | 直接尝试抢锁 | 高（减少上下文切换） | 大多数场景 |
| 公平锁 | 按 FIFO 顺序获取 | 低（保证公平） | 需要严格公平时 |

### 2.4 决策规则

| 条件 | 建议 | 强度 |
|------|------|------|
| 需要 tryLock 超时 | `lock.tryLock(timeout, unit)` | ✅ 必须用 ReentrantLock |
| 需要可中断 | `lock.lockInterruptibly()` | ✅ 必须用 ReentrantLock |
| 需要多个条件队列 | `lock.newCondition()` | ✅ 必须用 ReentrantLock |
| 需要公平锁 | `new ReentrantLock(true)` | ✅ 必须用 ReentrantLock |

### 2.5 风险边界（必须遵守）

```java
// ✅ 正确：finally 中释放
Lock lock = new ReentrantLock();
lock.lock();
try {
    // 业务逻辑
} finally {
    lock.unlock();  // 必须！
}

// ❌ 错误：忘记释放
lock.lock();
// 业务逻辑
lock.unlock();  // 异常时不会执行 → 死锁
```

---

## 3. synchronized vs ReentrantLock

| 特性 | synchronized | ReentrantLock |
|------|-------------|---------------|
| 实现层面 | JVM 内置（monitorenter/exit） | JDK API（AQS） |
| 锁释放 | 自动（退出同步块） | 手动（必须 unlock） |
| 可中断 | ❌ 不支持 | ✅ lockInterruptibly() |
| 超时获取 | ❌ 不支持 | ✅ tryLock(timeout) |
| 公平性 | 非公平 | 可选公平/非公平 |
| 条件变量 | 1 个（wait/notify） | 多个（newCondition） |
| 性能（JDK 6+） | 相近 | 竞争激烈时略优 |

### 决策树

```
需要高级特性（中断/超时/公平/多条件）？
├── 是 → ReentrantLock
└── 否 → synchronized（更简洁、不会忘记释放）
```

---

## 4. 读写锁（ReadWriteLock）

### 4.1 核心语义

| 要素 | 说明 |
|------|------|
| **是什么** | 读锁共享、写锁排他的分离锁 |
| **解决什么** | 读多写少场景，读操作不应该互斥 |
| **一句话** | 多个读可以并行，写必须独占 |

### 4.2 兼容矩阵

|  | 读锁 | 写锁 |
|--|------|------|
| 读锁 | ✅ 兼容 | ❌ 互斥 |
| 写锁 | ❌ 互斥 | ❌ 互斥 |

### 4.3 使用模式

```java
ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
Lock readLock = rwLock.readLock();
Lock writeLock = rwLock.writeLock();

// 读操作
readLock.lock();
try {
    // 读取数据（多个线程可并行）
} finally {
    readLock.unlock();
}

// 写操作
writeLock.lock();
try {
    // 修改数据（独占）
} finally {
    writeLock.unlock();
}
```

### 4.4 决策规则

| 条件 | 建议 | 强度 |
|------|------|------|
| 读:写 > 10:1 | 使用 ReadWriteLock | ✅ 推荐 |
| 读写均衡 | 普通锁即可 | ⚠️ 建议 |
| 需要乐观读 | 使用 StampedLock（JDK 8+） | ✅ 推荐 |

### 4.5 锁降级（支持）与锁升级（不支持）

```java
// ✅ 锁降级：写锁 → 读锁
writeLock.lock();
try {
    // 修改数据
    readLock.lock();  // 降级：先获取读锁
} finally {
    writeLock.unlock();  // 再释放写锁
}
// 现在持有读锁

// ❌ 锁升级：读锁 → 写锁（不支持，会死锁）
readLock.lock();
writeLock.lock();  // 永远阻塞 → 死锁！
```

---

## 5. 自适应自旋

### 5.1 核心语义

| 要素 | 说明 |
|------|------|
| **是什么** | 根据历史自旋成功率动态调整自旋次数 |
| **解决什么** | 固定自旋次数无法适应不同场景 |
| **JDK 版本** | JDK 6+ 引入 |

### 5.2 系统行为

```
上次自旋成功获取锁？
├── 是 → 增加本次自旋次数（很可能再次成功）
└── 否 → 减少自旋次数甚至跳过（直接阻塞更划算）
```

### 5.3 为什么需要

| 场景 | 自旋的效果 |
|------|-----------|
| 锁持有时间短 | 自旋优于阻塞（避免线程切换） |
| 锁持有时间长 | 自旋浪费 CPU（应该直接阻塞） |

---

## 6. 记忆锚点

| 概念 | 记忆句（≤20字） |
|------|----------------|
| synchronized | 自动锁，升级不降级 |
| ReentrantLock | 手动锁，功能强但别忘 unlock |
| 偏向锁 | 单人独享，记个 ID |
| 轻量级锁 | 交替用，CAS 争 |
| 重量级锁 | 真竞争，排队等 |
| 读写锁 | 读共享，写独占 |
| 自适应自旋 | 上次成功就多转，失败就少转 |
